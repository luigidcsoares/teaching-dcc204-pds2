                   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                    NOTAS DE AULA - 08 MODULARIZAÃ‡ÃƒO

                           Luigi D. C. Soares
                   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


ProgramaÃ§Ã£o Modular
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  â€¢ O que Ã©?

    "software design technique that emphasizes separating the
    functionality of a program into *independent*, interchangeable
    modules, such that each contains everything necessary to execute
    only one aspect of the desired functionality"

    (<https://en.wikipedia.org/wiki/Modular_programming>)

  â€¢ Quando/por quÃª utilizar?

  Queremos agrupar elementos que dizem respeito a uma mesma
  funcionalidade. Onde jÃ¡ vimos isso?
  â€¢ Classes: agrupamento local (campos)

  Ainda assim, classes representam algo bem especÃ­fico (lembram do
  princÃ­pio de responsabilidade Ãºnica? SRP), o que nÃ£o Ã© suficiente a
  medida que o sistema cresce e se torna mais complexo.

  Classes possuem diversas relaÃ§Ãµes entre si (voltaremos nisso). Algumas
  classes estÃ£o muito "prÃ³ximas", outras mais distantes. Como
  organizÃ¡-las? Qual o prÃ³ximo passo?

  MÃ³dulos!
  â€¢ Compilado separadamente, independentes (na medida do possÃ­velâ€¦
    dependÃªncias restritas as interfaces de outros mÃ³dulos)
  â€¢ ReutilizÃ¡vel e modificÃ¡vel
  â€¢ SRP ainda se aplica
  â€¢ CoesÃ£o: grau de dependÃªncia entre os elementos do mÃ³dulo (queremos
    *alta coesÃ£o*)
  â€¢ Acoplamento: grau de dependÃªncia entre diferentes mÃ³dulos (queremos
    *baixo acoplamento*)

  E como representar mÃ³dulos em C++?


Namespaces
â•â•â•â•â•â•â•â•â•â•

  Onde jÃ¡ vimos isso? `std::'

  E como podemos criar nossos prÃ³prios namespaces? Imagine que queremos
  criar um mÃ³dulo de containers

  seq.hpp (containers sequenciais)

  â”Œâ”€â”€â”€â”€
  â”‚ #ifndef CONTAINER_SEQ_H
  â”‚ #define CONTAINER_SEQ_H
  â”‚ 
  â”‚ namespace container {
  â”‚ template <typename T>
  â”‚ class Vector {
  â”‚ public:
  â”‚   Vector();
  â”‚   ~Vector();
  â”‚ 
  â”‚   void push_back(T e);
  â”‚   T at(std::size_t i) const;
  â”‚ 
  â”‚ private:
  â”‚   std::size_t _size;
  â”‚   std::size_t _capacity;
  â”‚   T *_vector;
  â”‚ };
  â”‚ 
  â”‚ template <typename T>
  â”‚ class LinkedList {
  â”‚   // ...
  â”‚ };
  â”‚ };
  â”‚ 
  â”‚ #include "vector.tpp"
  â”‚ #endif
  â””â”€â”€â”€â”€

  vector.tpp (implementando o vector)

  â”Œâ”€â”€â”€â”€
  â”‚ namespace container {
  â”‚ template <typename T> Vector<T>::Vector() {
  â”‚   _size = 0;
  â”‚   _capacity = 8;
  â”‚   _vector = new T[_capacity];
  â”‚ }
  â”‚ 
  â”‚ template <typename T> Vector<T>::~Vector() {
  â”‚   delete[] _vector;
  â”‚ }
  â”‚ 
  â”‚ template <typename T> void Vector<T>::push_back(T e) {
  â”‚   if (_size == _capacity) {
  â”‚     _capacity *= 2;
  â”‚     T *_new_vector = new T[_capacity];
  â”‚ 
  â”‚     for (std::size_t i = 0; i < _size; i++) {
  â”‚       _new_vector[i] = _vector[i];
  â”‚     }
  â”‚ 
  â”‚     delete[] _vector;
  â”‚     _vector = _new_vector;
  â”‚   }
  â”‚ 
  â”‚   _vector[_size] = e;
  â”‚   _size++;
  â”‚ }
  â”‚ 
  â”‚ template <typename T> T Vector<T>::at(std::size_t i) const {
  â”‚   return _vector[i];
  â”‚ }
  â”‚ }
  â””â”€â”€â”€â”€

  E agora vamos testar:

  main.cpp

  â”Œâ”€â”€â”€â”€
  â”‚ #include <iostream>
  â”‚ #include "seq.hpp"
  â”‚ 
  â”‚ int main() {
  â”‚   container::Vector<int> xs;
  â”‚ 
  â”‚   for (unsigned i = 0; i < 10; i++) {
  â”‚     xs.push_back(i);
  â”‚   }
  â”‚ 
  â”‚   std::cout << xs.at(8) << std::endl;
  â”‚   return 0;
  â”‚ }
  â””â”€â”€â”€â”€

  Podemos ter o mesmo namespace separado em mÃºltiplos arquivos

  assoc.hpp (containers associativos)

  â”Œâ”€â”€â”€â”€
  â”‚ #ifndef CONTAINER_ASSOC_H
  â”‚ #define CONTAINER_ASSOC_H
  â”‚ 
  â”‚ namespace container {
  â”‚ template <typename T>
  â”‚ class Set {
  â”‚   // ...
  â”‚ };
  â”‚ 
  â”‚ template <typename K, T>
  â”‚ class Map {
  â”‚   // ...
  â”‚ };
  â”‚ }
  â”‚ 
  â”‚ #endif
  â””â”€â”€â”€â”€


OrganizaÃ§Ã£o do Projeto
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  A forma como estruturamos nosso projeto tambÃ©m Ã© importante!

  Nosso prÃ³ximo mini-projeto: um sistema de gerenciamento.

  Vamos seguir (nÃ£o muito a risca, apenas para ilustrar) um padrÃ£o de
  projeto chamado DAO (Data Access Object), que consiste (bem por alto)
  em separar models (as entidades, que representam dados) da lÃ³gica de
  persistÃªncia dos dados (em um banco de dados, no nosso caso um arquivo
  CSV).

  A estrutura do projeto:

  â”Œâ”€â”€â”€â”€
  â”‚ book_management/
  â”‚ |__ include/
  â”‚     |__ database/
  â”‚         |__ csv.hpp
  â”‚     |__ dao/
  â”‚         |__ book.hpp
  â”‚     |__ model/
  â”‚         |__ book.hpp
  â”‚ |__ src/
  â”‚     |__ database/
  â”‚         |__ csv.cpp
  â”‚     |__ dao/
  â”‚         |__ book.cpp
  â”‚     |__ main.cpp
  â”‚ |__ Makefile
  â””â”€â”€â”€â”€


  ComeÃ§ando do model Book:

  include/model/book.hpp

  â”Œâ”€â”€â”€â”€
  â”‚ #ifndef MODEL_BOOK_H
  â”‚ #define MODEL_BOOK_H
  â”‚ 
  â”‚ #include <string>
  â”‚ 
  â”‚ namespace model {
  â”‚ struct Book {
  â”‚   std::string name;
  â”‚   std::string isbn;
  â”‚ };
  â”‚ }
  â”‚ #endif
  â””â”€â”€â”€â”€

  A parte de armazenamento no CSV:

  include/database/csv.hpp

  â”Œâ”€â”€â”€â”€
  â”‚ #ifndef DATABASE_CSV_H
  â”‚ #define DATABASE_CSV_H
  â”‚ 
  â”‚ #include <fstream>
  â”‚ #include <string>
  â”‚ #include <vector>
  â”‚ 
  â”‚ namespace database {
  â”‚ class CSV {
  â”‚ public:
  â”‚   using Line = std::vector<std::string>;
  â”‚ 
  â”‚   CSV(std::string file_path);
  â”‚   ~CSV();
  â”‚ 
  â”‚   std::vector<Line> get_lines();
  â”‚   void write(const std::vector<Line> &lines);
  â”‚ 
  â”‚ private:
  â”‚   std::ifstream _db_read;
  â”‚   std::ofstream _db_write;
  â”‚ };
  â”‚ }
  â”‚ 
  â”‚ #endif 
  â””â”€â”€â”€â”€

  E a implementaÃ§Ã£o do CSV:

  src/database/csv.cpp

  â”Œâ”€â”€â”€â”€
  â”‚ #include "database/csv.hpp"
  â”‚ #include <sstream>
  â”‚ 
  â”‚ namespace database {
  â”‚ CSV::CSV(std::string file_path)
  â”‚   : _db_read(file_path),
  â”‚     _db_write(file_path, std::ios::app) { }
  â”‚ 
  â”‚ CSV::~CSV() {
  â”‚   _db_read.close();
  â”‚   _db_write.close();
  â”‚ }
  â”‚ 
  â”‚ std::vector<CSV::Line> CSV::get_lines() {
  â”‚   std::vector<Line> lines;
  â”‚   std::string csv_line;
  â”‚ 
  â”‚   while (std::getline(_db_read, csv_line)) {
  â”‚     std::istringstream stream_line(csv_line);
  â”‚     std::string field;
  â”‚     Line line;
  â”‚ 
  â”‚     while (std::getline(stream_line, field, ',')) {
  â”‚       line.push_back(field);
  â”‚     }
  â”‚ 
  â”‚     lines.push_back(line);
  â”‚   }
  â”‚ 
  â”‚   _db_read.clear();
  â”‚   _db_read.seekg(0);
  â”‚ 
  â”‚   return lines;
  â”‚ }
  â”‚ 
  â”‚ void CSV::write(const std::vector<Line> &lines) {
  â”‚   for (Line line : lines) {
  â”‚     for (std::size_t i = 0; i < line.size(); i++) {
  â”‚       std::string field = line[i];
  â”‚       _db_write << field;
  â”‚       if (i < line.size() - 1) _db_write << ',';
  â”‚     }
  â”‚ 
  â”‚     _db_write << std::endl;
  â”‚   }
  â”‚ }
  â”‚ }
  â””â”€â”€â”€â”€

  E conectando o modelo com a persistÃªncia dos dados:
  â€¢ no mÃ©todo save, qual o efeito de retornar o prÃ³prio objeto Book?

  include/dao/book.hpp

  â”Œâ”€â”€â”€â”€
  â”‚ #ifndef DAO_BOOK_H
  â”‚ #define DAO_BOOK_H
  â”‚ 
  â”‚ #include "database/csv.hpp"
  â”‚ #include "model/book.hpp"
  â”‚ #include <vector>
  â”‚ 
  â”‚ namespace dao {
  â”‚ class Book {
  â”‚ public:
  â”‚   Book();
  â”‚   ~Book();
  â”‚ 
  â”‚   Book &save(model::Book book); 
  â”‚   std::vector<model::Book> get_all() const;
  â”‚ 
  â”‚ private:
  â”‚   std::size_t _new_begin;
  â”‚   std::vector<model::Book> _books;
  â”‚   database::CSV _db;
  â”‚ 
  â”‚   void _fetch_all();
  â”‚   void _persist();
  â”‚ };
  â”‚ }
  â”‚ 
  â”‚ #endif
  â””â”€â”€â”€â”€

  src/dao/book.cpp

  â”Œâ”€â”€â”€â”€
  â”‚ #include "dao/book.hpp"
  â”‚ 
  â”‚ namespace dao {
  â”‚ Book::Book() : _db("/tmp/books.csv") { 
  â”‚   _fetch_all();
  â”‚   _new_begin = _books.size();
  â”‚ }
  â”‚ 
  â”‚ void Book::_fetch_all() {
  â”‚   std::vector<database::CSV::Line> lines = _db.get_lines();
  â”‚   for (database::CSV::Line line : lines) {
  â”‚     model::Book book;
  â”‚     book.name = line[0];
  â”‚     book.isbn = line[1];
  â”‚     _books.push_back(book);
  â”‚   }
  â”‚ }
  â”‚ 
  â”‚ Book::~Book() {
  â”‚   _persist();
  â”‚ }
  â”‚ 
  â”‚ void Book::_persist()  {
  â”‚   std::vector<database::CSV::Line> lines;
  â”‚   for (std::size_t i = _new_begin; i < _books.size(); i++) {
  â”‚     model::Book book = _books[i];
  â”‚     database::CSV::Line line;
  â”‚     line.push_back(book.name);
  â”‚     line.push_back(book.isbn);
  â”‚     lines.push_back(line);
  â”‚   }
  â”‚   _db.write(lines);
  â”‚ }
  â”‚ 
  â”‚ Book &Book::save(model::Book book) {
  â”‚   _books.push_back(book);
  â”‚   return *this;
  â”‚ }
  â”‚ 
  â”‚ std::vector<model::Book> Book::get_all() const {
  â”‚   return _books;
  â”‚ }
  â”‚ }
  â””â”€â”€â”€â”€

  E a nossa aplicaÃ§Ã£o de fato (main):

  main.cpp

  â”Œâ”€â”€â”€â”€
  â”‚ #include "dao/book.hpp"
  â”‚ #include "model/book.hpp"
  â”‚ #include <iostream>
  â”‚ 
  â”‚ int main() {
  â”‚   dao::Book dao;
  â”‚   dao.save({"Harry Potter e a Pedra Filosofal", "978-8532523051"})
  â”‚      .save({"O Senhor dos AnÃ©is: A Sociedade do Anel", "978-8533613379"});
  â”‚ 
  â”‚   for (model::Book book : dao.get_all()) {
  â”‚     std::cout << book.name << " (" << book.isbn << ")" << std::endl;
  â”‚   }
  â”‚ 
  â”‚   return 0;
  â”‚ }
  â””â”€â”€â”€â”€


CompilaÃ§Ã£o
â•â•â•â•â•â•â•â•â•â•

  O processo de compilaÃ§Ã£o Ã© dividido em algumas etapas
  â€¢ PrÃ©-processamento
  â€¢ CompilaÃ§Ã£o de cada unidade de traduÃ§Ã£o para um arquivo objeto, ainda
    nÃ£o executÃ¡vel (dependÃªncias nÃ£o resolvidas)
  â€¢ LigaÃ§Ã£o entre objetos para resolver dependÃªncia de bibliotecas

  Quando fazemos `g++ -std=c++17 src/main.cpp src/database/csv.cpp
  src/dao/book.cpp -o main', estamos contemplando todas estas etapas

  Mas, note que seguindo este mÃ©todo qualquer alteraÃ§Ã£o em qualquer
  arquivo requer a recompilaÃ§Ã£o de *todos* os .cpp. Eu um projeto muito
  grande, isto pode ser muito ineficiente. Como resolver? Como
  recompilar apenas o que Ã© necessÃ¡rio?

  Ferramenta `make' + arquivo Makefile:
  â€¢ Podemos definir variÃ¡veis
  â€¢ O arquivo Makefile Ã© composto de targets (alvo)
  â€¢ O primeiro target Ã© o padrÃ£o do make (se nÃ£o for explÃ­cito)

  O arquivo Makefile Ã© composto de vÃ¡rios targets, na forma

  â”Œâ”€â”€â”€â”€
  â”‚ target: dependencia1 dependencia2 ... dependencia n
  â”‚         comando1
  â”‚         comando2
  â”‚         ...
  â”‚         comandok
  â””â”€â”€â”€â”€

  Por exemplo, podemos ter um target sem nenhuma dependÃªncia, que
  imprime uma mensagem na tela:

  â”Œâ”€â”€â”€â”€
  â”‚ run: 
  â”‚         echo "ğŸš€ Executing ..."
  â””â”€â”€â”€â”€

  Para executar, basta fazer `make run' e o resultado Ã©

  â”Œâ”€â”€â”€â”€
  â”‚ echo "ğŸš€ Executing ..."
  â”‚ ğŸš€ Executing ...
  â””â”€â”€â”€â”€

  Note que, alÃ©m da mensagem que gostarÃ­amos que fosse mostrada, tambÃ©m
  foi exibido o prÃ³prio comando que foi executado. Podemos suprimir essa
  informaÃ§Ã£o adicional com um "@":

  â”Œâ”€â”€â”€â”€
  â”‚ run: 
  â”‚         @echo "ğŸš€ Executing ..."
  â””â”€â”€â”€â”€

  E o resultado, com `make run':

  â”Œâ”€â”€â”€â”€
  â”‚ ğŸš€ Executing ...
  â””â”€â”€â”€â”€

  Caso executÃ¡ssemos apenas `make', sem nenhum target, o target padrÃ£o Ã©
  o primeiro do arquivo (de cima para baixo). Como, neste primeiro
  momento, temos apenas um target, o efeito seria o mesmo.

  AtÃ© entÃ£o, ainda nÃ£o fizemos nada de compilaÃ§Ã£o. Vamos tentar compilar
  o nosso projeto inteiro. O resultado serÃ¡ um arquivo executÃ¡vel "main"
  (poderia ser qualquer outro nome, talvez book_management) armazenado
  na pasta "bin/". Por conveniÃªncia, vamos definir o nome do target
  exatamente como o arquivo de saÃ­da: bin/main

  â”Œâ”€â”€â”€â”€
  â”‚ bin/main:
  â”‚         @echo "ğŸ›ï¸ ï¸ Building ..."
  â”‚         @mkdir -p bin/
  â”‚         g++ -std=c++17 -I include/ src/main.cpp src/database/csv.cpp src/dao/book.cpp -o bin/main
  â”‚ 
  â”‚ run: 
  â”‚         @echo "ğŸš€ Executing ..."
  â””â”€â”€â”€â”€

  Note que agora o target padrÃ£o Ã© o `bin/main', ou seja, `make' agora Ã©
  equivalente a `make bin/main'. E o resultado:

  â”Œâ”€â”€â”€â”€
  â”‚ ğŸ›ï¸ï¸ Building ...
  â”‚ g++ -std=c++17 -I include/ src/main.cpp src/database/csv.cpp src/dao/book.cpp -o bin/main
  â””â”€â”€â”€â”€

  Note que, se executar `make bin/main' novamente, a ferramenta make
  detecta que nÃ£o houveram alteraÃ§Ãµes, entÃ£o nÃ£o hÃ¡ necessidade de
  recompilar o projeto novamente. E o resultado Ã©

  â”Œâ”€â”€â”€â”€
  â”‚ make: 'bin/main' is up to date.
  â””â”€â”€â”€â”€

  Se estamos criando uma pasta, faz sentido querermos apagÃ¡-la tambÃ©m:

  â”Œâ”€â”€â”€â”€
  â”‚ bin/main:
  â”‚         @echo "ğŸ›ï¸ ï¸ Building ..."
  â”‚         @mkdir -p bin/
  â”‚         g++ -std=c++17 -I include/ src/main.cpp src/database/csv.cpp src/dao/book.cpp -o bin/main
  â”‚ 
  â”‚ run: 
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf bin/
  â””â”€â”€â”€â”€

  Agora, basta executar `make clean' e a pasta bin/ serÃ¡ deletada.

  E para executar nosso programa?

  â”Œâ”€â”€â”€â”€
  â”‚ bin/main:
  â”‚         @echo "ğŸ›ï¸ ï¸ Building ..."
  â”‚         @mkdir -p bin/
  â”‚         g++ -std=c++17 -I include/ src/main.cpp src/database/csv.cpp src/dao/book.cpp -o bin/main
  â”‚ 
  â”‚ run: 
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚         @bin/main
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf bin/
  â””â”€â”€â”€â”€

  E o resultado de `make run':

  â”Œâ”€â”€â”€â”€
  â”‚ ğŸš€ Executing ...
  â”‚ Harry Potter e a Pedra Filosofal (978-8532523051)
  â”‚ O Senhor dos AnÃ©is: A Sociedade do Anel (978-8533613379)
  â””â”€â”€â”€â”€

  Note que estamos nos referindo a pasta "bin/" em mais de um lugar. E
  se quisÃ©ssemos alterar esta para uma outra pasta? PrecisarÃ­amos
  alterar vÃ¡rias partes do Makefile. Ao invÃ©s disso, podemos definir uma
  variÃ¡vel (e aÃ­ bastaria alterar a variÃ¡vel):

  â”Œâ”€â”€â”€â”€
  â”‚ BIN := bin
  â”‚ 
  â”‚ ${BIN}/main:
  â”‚         @echo "ğŸ›ï¸ ï¸ Building ..."
  â”‚         @mkdir -p ${BIN}/
  â”‚         g++ -std=c++17 -I include/ src/main.cpp src/database/csv.cpp src/dao/book.cpp -o ${BIN}/main
  â”‚ 
  â”‚ run: 
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚         @${BIN}/main
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf ${BIN}/
  â””â”€â”€â”€â”€

  Vamos fazer o mesmo para as outras pastas, para o compilador (e se
  quissÃ©ssemos futuramente usar outro compilador, talvez o clang++?), as
  flags que passamos para o compilador, etc:

  â”Œâ”€â”€â”€â”€
  â”‚ CXX := g++
  â”‚ CXXFLAGS := -std=c++17
  â”‚ 
  â”‚ INCLUDE := include
  â”‚ SRC := src
  â”‚ BIN := bin
  â”‚ EXEC := main
  â”‚ 
  â”‚ ${BIN}/${EXEC}:
  â”‚         @echo "ğŸ›ï¸ ï¸ Building ..."
  â”‚         @mkdir -p ${BIN}/
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE}/ ${SRC}/main.cpp ${SRC}/database/csv.cpp ${SRC}/dao/book.cpp -o ${BIN}/${EXEC}
  â”‚ 
  â”‚ run: 
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚         @${BIN}/main
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf ${BIN}/
  â””â”€â”€â”€â”€

  E se tentÃ¡ssemos rodar `make run' sem antes compilar o projeto? Ou,
  basicamente, `make clean' seguido por `make run'? O resultado

  â”Œâ”€â”€â”€â”€
  â”‚ ğŸš€ Executing ...
  â”‚ make: bin/main: No such file or directory
  â”‚ make: *** [Makefile:16: run] Error 127
  â””â”€â”€â”€â”€

  O arquivo bin/main nÃ£o existeâ€¦ Como garantir que, ao tentar executar o
  programa, ele estarÃ¡ compilado? Adicionamos uma dependÃªncia ao target
  run:

  â”Œâ”€â”€â”€â”€
  â”‚ CXX := g++
  â”‚ CXXFLAGS := -std=c++17
  â”‚ 
  â”‚ INCLUDE := include
  â”‚ SRC := src
  â”‚ BIN := bin
  â”‚ EXEC := main
  â”‚ 
  â”‚ ${BIN}/${EXEC}:
  â”‚         @echo "ğŸ›ï¸ ï¸ Building ..."
  â”‚         @mkdir -p ${BIN}/
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE}/ ${SRC}/main.cpp ${SRC}/database/csv.cpp ${SRC}/dao/book.cpp -o ${BIN}/${EXEC}
  â”‚ 
  â”‚ run: ${BIN}/${EXEC}
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚         @${BIN}/main
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf ${BIN}/
  â””â”€â”€â”€â”€

  JÃ¡ temos um Makefile funcional, mas ainda temos aquele problema de se
  atualizarmos algum dos arquivos, temos que recompilar o projeto
  inteiro. Vamos separar o processo de compilaÃ§Ã£o em vÃ¡rias
  etapas. Primeiro, vamos construir o arquivo objeto do
  database/csv.cpp. Vamos armazenar esses arquivos objetos em uma pasta
  "build":

  â”Œâ”€â”€â”€â”€
  â”‚ CXX := g++
  â”‚ CXXFLAGS := -std=c++17
  â”‚ 
  â”‚ INCLUDE := include
  â”‚ SRC := src
  â”‚ BIN := bin
  â”‚ BUILD := build
  â”‚ EXEC := main
  â”‚ 
  â”‚ ${BIN}/${EXEC}:
  â”‚         @echo "ğŸ›ï¸ ï¸ Building ..."
  â”‚         @mkdir -p ${BIN}/
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE}/ ${SRC}/main.cpp ${SRC}/database/csv.cpp ${SRC}/dao/book.cpp -o ${BIN}/${EXEC}
  â”‚ 
  â”‚ ${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
  â”‚         @echo "ğŸ›ï¸ ï¸ Building db_csv.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/database/csv.cpp -o ${BUILD}/db_csv.o
  â”‚ 
  â”‚ run: ${BIN}/${EXEC}
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚         @${BIN}/main
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf ${BIN}/ ${BUILD}/
  â””â”€â”€â”€â”€

  E agora para o dao/book.cpp. Note que este cara depende, tambÃ©m, do
  model/book.hpp e database/csv.hpp (das interfaces):

  â”Œâ”€â”€â”€â”€
  â”‚ CXX := g++
  â”‚ CXXFLAGS := -std=c++17
  â”‚ 
  â”‚ INCLUDE := include
  â”‚ SRC := src
  â”‚ BIN := bin
  â”‚ BUILD := build
  â”‚ EXEC := main
  â”‚ 
  â”‚ ${BIN}/${EXEC}:
  â”‚         @echo "ğŸ›ï¸ ï¸ Building ..."
  â”‚         @mkdir -p ${BIN}/
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE}/ ${SRC}/main.cpp ${SRC}/database/csv.cpp ${SRC}/dao/book.cpp -o ${BIN}/${EXEC}
  â”‚ 
  â”‚ ${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
  â”‚         @echo "ğŸ›ï¸ ï¸ Building db_csv.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/database/csv.cpp -o ${BUILD}/db_csv.o
  â”‚ 
  â”‚ ${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
  â”‚         @echo "ğŸ›ï¸  Building dao_book.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/dao/book.cpp -o ${BUILD}/dao_book.o
  â”‚ 
  â”‚ run: ${BIN}/${EXEC}
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚         @${BIN}/main
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf ${BIN}/ ${BUILD}/
  â””â”€â”€â”€â”€

  Por fim, o Ãºltimo objeto referente ao src/main.cpp:

  â”Œâ”€â”€â”€â”€
  â”‚ CXX := g++
  â”‚ CXXFLAGS := -std=c++17
  â”‚ 
  â”‚ INCLUDE := include
  â”‚ SRC := src
  â”‚ BIN := bin
  â”‚ BUILD := build
  â”‚ EXEC := main
  â”‚ 
  â”‚ ${BIN}/${EXEC}:
  â”‚         @echo "ğŸ›ï¸ ï¸ Building ..."
  â”‚         @mkdir -p ${BIN}/
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE}/ ${SRC}/main.cpp ${SRC}/database/csv.cpp ${SRC}/dao/book.cpp -o ${BIN}/${EXEC}
  â”‚ 
  â”‚ ${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
  â”‚         @echo "ğŸ›ï¸ ï¸ Building db_csv.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/database/csv.cpp -o ${BUILD}/db_csv.o
  â”‚ 
  â”‚ ${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
  â”‚         @echo "ğŸ›ï¸  Building dao_book.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/dao/book.cpp -o ${BUILD}/dao_book.o
  â”‚ 
  â”‚ ${BUILD}/main.o: ${SRC}/main.cpp ${INCLUDE}/model/book.hpp ${INCLUDE}/dao/book.hpp
  â”‚         @echo "ğŸ›ï¸  Building main.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/main.cpp -o ${BUILD}/main.o
  â”‚ 
  â”‚ run: ${BIN}/${EXEC}
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚         @${BIN}/main
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf ${BIN}/ ${BUILD}/
  â””â”€â”€â”€â”€

  Agora, precisamos ligar todos estes objetos. Vamos alterar o primeiro
  target. Quais as dependÃªncias? Os objetos!

  â”Œâ”€â”€â”€â”€
  â”‚ CXX := g++
  â”‚ CXXFLAGS := -std=c++17
  â”‚ 
  â”‚ INCLUDE := include
  â”‚ SRC := src
  â”‚ BIN := bin
  â”‚ BUILD := build
  â”‚ EXEC := main
  â”‚ 
  â”‚ ${BIN}/${EXEC}: ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o
  â”‚         @echo "ï¸ğŸ”§ ï¸Installing ${EXEC}..."
  â”‚         @mkdir -p ${BIN}/
  â”‚         ${CXX} ${CXXFLAGS} ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o -o ${BIN}/${EXEC}
  â”‚ 
  â”‚ ${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
  â”‚         @echo "ğŸ›ï¸ ï¸ Building db_csv.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/database/csv.cpp -o ${BUILD}/db_csv.o
  â”‚ 
  â”‚ ${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
  â”‚         @echo "ğŸ›ï¸  Building dao_book.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/dao/book.cpp -o ${BUILD}/dao_book.o
  â”‚ 
  â”‚ ${BUILD}/main.o: ${SRC}/main.cpp ${INCLUDE}/model/book.hpp ${INCLUDE}/dao/book.hpp
  â”‚         @echo "ğŸ›ï¸  Building main.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/main.cpp -o ${BUILD}/main.o
  â”‚ 
  â”‚ run: ${BIN}/${EXEC}
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚         @${BIN}/main
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf ${BIN}/ ${BUILD}/
  â””â”€â”€â”€â”€

  Estamos repetindo vÃ¡rias coisas. Por exemplo, o nome dos targets e os
  arquivos de saÃ­da. Podemos simplificar.
  â€¢ $@ equivale ao target

  â”Œâ”€â”€â”€â”€
  â”‚ CXX := g++
  â”‚ CXXFLAGS := -std=c++17
  â”‚ 
  â”‚ INCLUDE := include
  â”‚ SRC := src
  â”‚ BIN := bin
  â”‚ BUILD := build
  â”‚ EXEC := main
  â”‚ 
  â”‚ ${BIN}/${EXEC}: ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o
  â”‚         @echo "ï¸ğŸ”§ ï¸Installing ${EXEC}..."
  â”‚         @mkdir -p ${BIN}/
  â”‚         ${CXX} ${CXXFLAGS} ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o -o $@
  â”‚ 
  â”‚ ${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
  â”‚         @echo "ğŸ›ï¸ ï¸ Building db_csv.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/database/csv.cpp -o $@
  â”‚ 
  â”‚ ${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
  â”‚         @echo "ğŸ›ï¸  Building dao_book.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/dao/book.cpp -o $@
  â”‚ 
  â”‚ ${BUILD}/main.o: ${SRC}/main.cpp ${INCLUDE}/model/book.hpp ${INCLUDE}/dao/book.hpp
  â”‚         @echo "ğŸ›ï¸  Building main.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c ${SRC}/main.cpp -o $@
  â”‚ 
  â”‚ run: ${BIN}/${EXEC}
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚         @${BIN}/main
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf ${BIN}/ ${BUILD}/
  â””â”€â”€â”€â”€

  â€¢ $< equivale a primeira dependÃªncia da lista, que em muitos casos Ã© o
    arquivo .cpp que irÃ¡ virar um objeto:

  â”Œâ”€â”€â”€â”€
  â”‚ CXX := g++
  â”‚ CXXFLAGS := -std=c++17
  â”‚ 
  â”‚ INCLUDE := include
  â”‚ SRC := src
  â”‚ BIN := bin
  â”‚ BUILD := build
  â”‚ EXEC := main
  â”‚ 
  â”‚ ${BIN}/${EXEC}: ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o
  â”‚         @echo "ï¸ğŸ”§ ï¸Installing ${EXEC}..."
  â”‚         @mkdir -p ${BIN}/
  â”‚         ${CXX} ${CXXFLAGS} ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o -o $@
  â”‚ 
  â”‚ ${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
  â”‚         @echo "ğŸ›ï¸ ï¸ Building db_csv.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@
  â”‚ 
  â”‚ ${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
  â”‚         @echo "ğŸ›ï¸  Building dao_book.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@
  â”‚ 
  â”‚ ${BUILD}/main.o: ${SRC}/main.cpp ${INCLUDE}/model/book.hpp ${INCLUDE}/dao/book.hpp
  â”‚         @echo "ğŸ›ï¸  Building main.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@
  â”‚ 
  â”‚ run: ${BIN}/${EXEC}
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚         @${BIN}/main
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf ${BIN}/ ${BUILD}/
  â””â”€â”€â”€â”€

  â€¢ $^ equivale as dependÃªncias, que estamos repetindo na etapa de
    ligaÃ§Ã£o dos objetos

  â”Œâ”€â”€â”€â”€
  â”‚ CXX := g++
  â”‚ CXXFLAGS := -std=c++17
  â”‚ 
  â”‚ INCLUDE := include
  â”‚ SRC := src
  â”‚ BIN := bin
  â”‚ BUILD := build
  â”‚ EXEC := main
  â”‚ 
  â”‚ ${BIN}/${EXEC}: ${BUILD}/db_csv.o ${BUILD}/dao_book.o ${BUILD}/main.o
  â”‚         @echo "ï¸ğŸ”§ ï¸Installing ${EXEC}..."
  â”‚         @mkdir -p ${BIN}/
  â”‚         ${CXX} ${CXXFLAGS} $^ -o $@
  â”‚ 
  â”‚ ${BUILD}/db_csv.o: ${SRC}/database/csv.cpp ${INCLUDE}/database/csv.hpp
  â”‚         @echo "ğŸ›ï¸ ï¸ Building db_csv.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@
  â”‚ 
  â”‚ ${BUILD}/dao_book.o: ${SRC}/dao/book.cpp ${INCLUDE}/dao/book.hpp ${INCLUDE}/database/csv.hpp ${INCLUDE}/model/book.hpp
  â”‚         @echo "ğŸ›ï¸  Building dao_book.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@
  â”‚ 
  â”‚ ${BUILD}/main.o: ${SRC}/main.cpp ${INCLUDE}/model/book.hpp ${INCLUDE}/dao/book.hpp
  â”‚         @echo "ğŸ›ï¸  Building main.o ..."
  â”‚         @mkdir -p ${BUILD}
  â”‚         ${CXX} ${CXXFLAGS} -I ${INCLUDE} -c $< -o $@
  â”‚ 
  â”‚ run: ${BIN}/${EXEC}
  â”‚         @echo "ğŸš€ Executing ..."
  â”‚         @${BIN}/main
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf ${BIN}/ ${BUILD}/
  â””â”€â”€â”€â”€

  E tem maisâ€¦ Ã© possÃ­vel automatizar as dependÃªncias, simplificar outras
  coisas (vai ficando mais complexo). Mas, com o "bÃ¡sico" vocÃªs jÃ¡
  conseguem automatizar muita coisa do processo de compilaÃ§Ã£o.
