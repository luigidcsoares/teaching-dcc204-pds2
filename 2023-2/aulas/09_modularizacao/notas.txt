                   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                    NOTAS DE AULA - 09 MODULARIZAÃ‡ÃƒO

                           Luigi D. C. Soares
                   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


ProgramaÃ§Ã£o Modular
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  â€¢ O que Ã©?

    "software design technique that emphasizes separating the
    functionality of a program into *independent*, interchangeable
    modules, such that each contains everything necessary to execute
    only one aspect of the desired functionality"

    (<https://en.wikipedia.org/wiki/Modular_programming>)

  â€¢ Quando/por quÃª utilizar?

  Queremos agrupar elementos que dizem respeito a uma mesma
  funcionalidade. Onde jÃ¡ vimos isso?

  â€¢ Classes: agrupamento local (campos)

  Ainda assim, classes representam algo bem especÃ­fico (lembram do
  princÃ­pio de responsabilidade Ãºnica? SRP), o que nÃ£o Ã© suficiente a
  medida que o sistema cresce e se torna mais complexo.

  Classes possuem diversas relaÃ§Ãµes entre si (voltaremos nisso). Algumas
  classes estÃ£o muito "prÃ³ximas", outras mais distantes. Como
  organizÃ¡-las? Qual o prÃ³ximo passo?

  MÃ³dulos!
  â€¢ Independente (na medida do possÃ­velâ€¦ dependÃªncias restritas as
    interfaces de outros mÃ³dulos)
  â€¢ ReutilizÃ¡vel e modificÃ¡vel
  â€¢ SRP ainda se aplica
  â€¢ CoesÃ£o: grau de dependÃªncia entre os elementos do mÃ³dulo (queremos
    *alta coesÃ£o*)
  â€¢ Acoplamento: grau de dependÃªncia entre diferentes mÃ³dulos (queremos
    *baixo acoplamento*)

  E como representar mÃ³dulos em C++? Isto Ã©, como agrupar
  classes/funcionalidades?


Namespaces
â•â•â•â•â•â•â•â•â•â•

  â€¢ Onde jÃ¡ vimos isso? `std::'
  â€¢ E como podemos criar nossos prÃ³prios namespaces?

  `message.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ namespace mail_lib {
  â”‚ struct Message {
  â”‚   std::string from;
  â”‚   std::string to;
  â”‚   std::string subject;
  â”‚   std::string content;
  â”‚ };
  â”‚ }
  â””â”€â”€â”€â”€

  `mailbox.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ namespace mail_lib {
  â”‚ class Mailbox { ... };
  â”‚ }
  â””â”€â”€â”€â”€

  â€¢ E como utilizar?

  â”Œâ”€â”€â”€â”€
  â”‚ mail_lib::Message msg;
  â”‚ mail_lib::Mailbox mbox;
  â””â”€â”€â”€â”€

  â€¢ Podemos, inclusive, concatenar espaÃ§os de nome:

  `mailbox.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ namespace mail_lib::core {
  â”‚ class Mailbox { ... };
  â”‚ }
  â””â”€â”€â”€â”€

  `yaml.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ namespace mail_lib::storage {
  â”‚ class YAML { ... };
  â”‚ }
  â””â”€â”€â”€â”€

  â€¢ E para usar:

  â”Œâ”€â”€â”€â”€
  â”‚ mail_lib::core::Mailbox mbox;
  â”‚ mail_lib::storage::YAML storage;
  â””â”€â”€â”€â”€

  â€¢ Ou podemos "renomear":

  â”Œâ”€â”€â”€â”€
  â”‚ namespace core = mail_lib::core;
  â”‚ namespace storage = mail_lib::storage;
  â”‚ 
  â”‚ core::Mailbox mbox;
  â”‚ storage::YAML storage;
  â””â”€â”€â”€â”€

  â€¢ `mail_lib' aqui estÃ¡ servindo como o espaÃ§o de nomes da nossa
    biblioteca como um todo (que veremos a seguir)
  â€¢ `mail_lib::core' Ã© o mÃ³dulo que agrupa as funcionalidades
    relacionadas ao sistema de emails
  â€¢ `mail_lib::storage' Ã© o mÃ³dulo que agrupa as funcionalidades
    relacionadas ao armazenamento dos dados


OrganizaÃ§Ã£o do Projeto
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  A forma como estruturamos nosso projeto tambÃ©m Ã© importante!

  Nosso primeiro mini-projeto: uma biblioteca para gerenciamento de um
  sistema de emails

  A estrutura do projeto:

  â”Œâ”€â”€â”€â”€
  â”‚ mail-lib/
  â”‚ |__ bin/
  â”‚ |__ build/
  â”‚ |__ doc/
  â”‚ |__ include/
  â”‚     |__ core/
  â”‚         |__ mailapp.hpp
  â”‚         |__ mailbox.hpp
  â”‚         |__ message.hpp
  â”‚     |__ storage/
  â”‚         |__ yaml.hpp
  â”‚ |__ src/
  â”‚     |__ core/
  â”‚         |__ mailapp.cpp
  â”‚         |__ mailbox.cpp
  â”‚     |__ storage/
  â”‚         |__ yaml.cpp
  â”‚ |__ test/
  â”‚     |__ core/
  â”‚         |__ mailapp.cpp
  â”‚         |__ mailbox.cpp
  â”‚     |__ storage/
  â”‚         |__ yaml.cpp
  â”‚         |__ driver.cpp
  â”‚ |__ Doxyfile
  â”‚ |__ Makefile
  â””â”€â”€â”€â”€

  Temos um mÃ³dulo `mail_lib::core' agrupando as funcionalidades de
  `Message', `Mailbox', e `Mailapp':

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ #include <string>
  â”‚ 
  â”‚ namespace mail_lib::core {
  â”‚ struct Message {
  â”‚   std::string from;
  â”‚   std::string to;
  â”‚   std::string subject;
  â”‚   std::string content;
  â”‚ };
  â”‚ }
  â””â”€â”€â”€â”€
  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ #include "message.hpp"
  â”‚ 
  â”‚ #include <string>
  â”‚ #include <vector>
  â”‚ 
  â”‚ namespace mail_lib::core {
  â”‚ class Mailbox {
  â”‚ public:
  â”‚   /// @brief Inicializa a caixa com um determinado nome, mas vazia
  â”‚   ///
  â”‚   /// Detalhes...
  â”‚   /// @param name Nome da caixa de mensagens (e.g., inbox)
  â”‚   Mailbox(std::string name);
  â”‚ 
  â”‚   /// @brief Inicializa a caixa com mensagens previamente lidas
  â”‚   /// @param name Nome da caixa de mensagens (e.g., inbox)
  â”‚   /// @param msgs Vetor de mensagens, onde a **Ãºltima** deve ser
  â”‚   ///             a mais recente (idealmente teria um timestamp...)
  â”‚   Mailbox(std::string name, std::vector<Message> const &msgs);
  â”‚ 
  â”‚   /// @brief Adiciona uma mensagem ao final da lista
  â”‚   /// @param msg Mensagem a ser adicionada
  â”‚   /// @return A prÃ³pria caixa, para chamadas consecutivas
  â”‚   Mailbox &add(Message msg);
  â”‚ 
  â”‚   /// @return A lista de mensagens, em que o Ãºltimo elemento Ã©
  â”‚   ///         a mensagem adicionada mais recentemente
  â”‚   std::vector<Message> read_all() const;
  â”‚ 
  â”‚   /// @return Nome da caixa de entrada
  â”‚   std::string name() const;
  â”‚ 
  â”‚ private:
  â”‚   std::string _name;
  â”‚   std::vector<Message> _msgs;
  â”‚ };
  â”‚ };
  â””â”€â”€â”€â”€
  â”Œâ”€â”€â”€â”€
  â”‚ #include "mailbox.hpp"
  â”‚ #include "message.hpp"
  â”‚ 
  â”‚ #include <vector>
  â”‚ 
  â”‚ namespace mail_lib::core {
  â”‚ Mailbox::Mailbox(std::string name, std::vector<Message> const &msgs) {
  â”‚   _name = name;
  â”‚   _msgs = msgs;
  â”‚ }
  â”‚ 
  â”‚ Mailbox::Mailbox(std::string name) : Mailbox(name, {}) {}
  â”‚ 
  â”‚ 
  â”‚ Mailbox &Mailbox::add(Message msg) {
  â”‚   _msgs.push_back(msg);
  â”‚   return *this;
  â”‚ }
  â”‚ 
  â”‚ std::vector<Message> Mailbox::read_all() const {
  â”‚   return _msgs;
  â”‚ }
  â”‚ 
  â”‚ std::string Mailbox::name() const {
  â”‚   return _name;
  â”‚ }
  â”‚ }
  â””â”€â”€â”€â”€
  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ #include "mailbox.hpp"
  â”‚ #include "message.hpp"
  â”‚ #include "yaml.hpp"
  â”‚ 
  â”‚ namespace mail_lib::core {
  â”‚ class Mailapp {
  â”‚ public:
  â”‚   /// @brief InicializaÃ§Ã£o das caixas de entrada e saÃ­da
  â”‚   ///
  â”‚   /// Busca as mensagens lidas e enviadas pelo usuÃ¡rio,
  â”‚   /// para inicializar as caixas de mensagens.
  â”‚   ///
  â”‚   /// FIXME: obviamente, aqui (ou em algum passo antes)
  â”‚   ///        deveria ter alguma etapa de autenticaÃ§Ã£o...
  â”‚   ///
  â”‚   /// @param user UsuÃ¡rio (email) que estÃ¡ logado
  â”‚   Mailapp(std::string user);
  â”‚ 
  â”‚   /// @brief Realiza o flush das caixas de mensagem
  â”‚   ~Mailapp();
  â”‚ 
  â”‚   /// @return A caixa de entrada, para leitura de emails recebidos
  â”‚   Mailbox inbox() const;
  â”‚ 
  â”‚   /// @return A caixa de saÃ­da, para leitura de emails enviados
  â”‚   Mailbox sent() const;
  â”‚ 
  â”‚   /// @brief Adiciona nova mensagem Ã  caixa de saÃ­da
  â”‚   Mailapp &send_message(std::string to, std::string subject, std::string content);
  â”‚ 
  â”‚ private:
  â”‚   std::string _user;
  â”‚ 
  â”‚   Mailbox _inbox = Mailbox("inbox");
  â”‚   Mailbox _sent = Mailbox("sent");
  â”‚ 
  â”‚   unsigned _start_new_inbox = 0;
  â”‚   unsigned _start_new_sent = 0;
  â”‚ 
  â”‚   storage::YAML _user_storage;
  â”‚ };
  â”‚ }
  â””â”€â”€â”€â”€
  â”Œâ”€â”€â”€â”€
  â”‚ #include "mailapp.hpp"
  â”‚ #include "mailbox.hpp"
  â”‚ #include "yaml.hpp"
  â”‚ #include <iostream>
  â”‚ 
  â”‚ namespace mail_lib::core {
  â”‚ Mailapp::Mailapp(std::string user) : _user(user), _user_storage(user) {
  â”‚   auto mboxes = _user_storage.load();
  â”‚ 
  â”‚   auto inbox_it = mboxes.find("inbox");
  â”‚   if (inbox_it != mboxes.end()) {
  â”‚     _inbox = inbox_it->second;
  â”‚     _start_new_inbox = _inbox.read_all().size();
  â”‚   }
  â”‚ 
  â”‚   auto sent_it = mboxes.find("sent");
  â”‚   if (sent_it != mboxes.end()) {
  â”‚     _sent = sent_it->second;
  â”‚     _start_new_sent = _sent.read_all().size();
  â”‚   }
  â”‚ }
  â”‚ 
  â”‚ Mailapp::~Mailapp() {
  â”‚   Mailbox new_inbox("inbox");
  â”‚   auto inbox_msgs = _inbox.read_all();
  â”‚   for (unsigned i = _start_new_inbox; i < inbox_msgs.size(); i++) {
  â”‚     new_inbox.add(inbox_msgs[i]);
  â”‚   }
  â”‚ 
  â”‚   Mailbox new_sent("sent");
  â”‚   auto sent_msgs = _sent.read_all();
  â”‚   for (unsigned i = _start_new_sent; i < sent_msgs.size(); i++) {
  â”‚     new_sent.add(sent_msgs[i]);
  â”‚   }
  â”‚ 
  â”‚   _user_storage.save({new_inbox, new_sent});
  â”‚ }
  â”‚ 
  â”‚ Mailbox Mailapp::inbox() const {
  â”‚   return _inbox;
  â”‚ }
  â”‚ 
  â”‚ Mailbox Mailapp::sent() const {
  â”‚   return _sent;
  â”‚ }
  â”‚ 
  â”‚ Mailapp &Mailapp::send_message(std::string to, std::string subject, std::string content) {
  â”‚   Message m = {_user, to, subject, content};
  â”‚   _sent.add(m);
  â”‚ 
  â”‚   // Aqui estamos acessando a pasta de um usuÃ¡rio nÃ£o autenticado,
  â”‚   // possÃ­vel fonte de problemas/ataques...
  â”‚   // Mas Ã© sÃ³ um exemplo para as aulas, entÃ£o vamos simplificar;
  â”‚   storage::YAML(to).save({ Mailbox("inbox").add(m) });
  â”‚ 
  â”‚   return *this;
  â”‚ }
  â”‚ }
  â””â”€â”€â”€â”€
  E temos o mÃ³dulo `mail_lib::storage', composto pela classe `YAML':

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ #include "mailbox.hpp"
  â”‚ 
  â”‚ #include <fstream>
  â”‚ #include <unordered_map>
  â”‚ #include <string>
  â”‚ 
  â”‚ namespace mail_lib::storage {
  â”‚ class YAML {
  â”‚ public:
  â”‚   /// @brief Inicializa o gerenciador YAML das caixas do usuÃ¡rio
  â”‚   ///
  â”‚   /// O diretÃ³rio do usuÃ¡rio Ã© criado vazio, caso nÃ£o exista
  â”‚   YAML(std::string user);
  â”‚ 
  â”‚   /// TODO: poderia verificar se os arquivos nÃ£o foram alterados,
  â”‚   ///       para evitar loads em sequÃªncia...
  â”‚   /// @return Lista de mailboxes do usuÃ¡rio
  â”‚   std::unordered_map<std::string, core::Mailbox> load();
  â”‚ 
  â”‚   /// @brief Persiste as mailboxes nos arquivos do usuÃ¡rio.
  â”‚   YAML &save(std::vector<core::Mailbox> const &mboxes);
  â”‚ 
  â”‚ private:
  â”‚   std::string _user_path;
  â”‚   std::unordered_map<std::string, std::fstream> _user_files;
  â”‚ };
  â”‚ }
  â””â”€â”€â”€â”€
  â”Œâ”€â”€â”€â”€
  â”‚ #include "yaml.hpp"
  â”‚ #include "mailbox.hpp"
  â”‚ 
  â”‚ #include <filesystem>
  â”‚ #include <iomanip>
  â”‚ #include <sstream>
  â”‚ #include <string>
  â”‚ #include <unordered_map>
  â”‚ 
  â”‚ namespace fs = std::filesystem;
  â”‚ 
  â”‚ namespace mail_lib::storage {
  â”‚ YAML::YAML(std::string user) {
  â”‚   _user_path = STORAGE_DIR"/" + user + "/";
  â”‚   fs::create_directory(_user_path); // Cria diretÃ³rio, se nÃ£o existe
  â”‚ 
  â”‚   for (auto const &entry : fs::directory_iterator(_user_path)) {
  â”‚     auto const &file_path = entry.path();
  â”‚     auto file_mode = std::fstream::in | std::fstream::out | std::fstream::app;
  â”‚     _user_files[file_path.stem()] = std::fstream(file_path.c_str(), file_mode);
  â”‚   }
  â”‚ }
  â”‚ 
  â”‚ std::unordered_map<std::string, core::Mailbox> YAML::load() {
  â”‚   std::unordered_map<std::string, core::Mailbox> mboxes;
  â”‚   for (auto &file : _user_files) {
  â”‚     std::string filename = file.first;
  â”‚     std::fstream &fs = file.second;
  â”‚     std::string item;
  â”‚ 
  â”‚     std::vector<core::Message> msgs;
  â”‚     fs.seekg(std::ios::beg);
  â”‚ 
  â”‚     while (std::getline(fs, item)) {
  â”‚       core::Message msg;
  â”‚ 
  â”‚       std::istringstream stream(item.substr(item.find(":") + 2));
  â”‚       stream >> std::quoted(msg.from);
  â”‚ 
  â”‚       std::getline(fs, item);
  â”‚       stream.str(item.substr(item.find(":") + 2));
  â”‚       stream >> std::quoted(msg.to);
  â”‚ 
  â”‚       std::getline(fs, item);
  â”‚       stream.str(item.substr(item.find(":") + 2));
  â”‚       stream >> std::quoted(msg.subject);
  â”‚ 
  â”‚       std::getline(fs, item);
  â”‚       stream.str(item.substr(item.find(":") + 2));
  â”‚       stream >> std::quoted(msg.content);
  â”‚ 
  â”‚       msgs.push_back(msg);
  â”‚     }
  â”‚     mboxes.try_emplace(filename, filename, msgs);
  â”‚   }
  â”‚   return mboxes;
  â”‚ }
  â”‚ 
  â”‚ YAML &YAML::save(std::vector<core::Mailbox> const &mboxes) {
  â”‚   for (core::Mailbox const &mbox: mboxes) {
  â”‚     std::string filename = mbox.name();
  â”‚ 
  â”‚     if (!_user_files.count(filename)) {
  â”‚       auto file_mode = std::fstream::in | std::fstream::out | std::fstream::app;
  â”‚       _user_files[filename] = std::fstream(_user_path + filename + ".yaml", file_mode);
  â”‚     }
  â”‚ 
  â”‚     std::fstream &fs = _user_files[filename];
  â”‚     for (core::Message const &msg : mbox.read_all()) {
  â”‚       fs << "- from: \"" << msg.from << "\"" << std::endl;;
  â”‚       fs << "  to: \"" << msg.to << "\"" << std::endl;
  â”‚       fs << "  subject: \"" << msg.subject << "\"" << std::endl;
  â”‚       fs << "  content: \"" << msg.content << "\"" << std::endl;
  â”‚     }
  â”‚   }
  â”‚   return *this;
  â”‚ }
  â”‚ }
  â””â”€â”€â”€â”€
  Por fim, temos tambÃ©m os testes para cada uma das classes, tambÃ©m
  organizados pelos mÃ³dulos:

  â”Œâ”€â”€â”€â”€
  â”‚ #define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
  â”‚ #include <doctest.hpp>
  â””â”€â”€â”€â”€
  â”Œâ”€â”€â”€â”€
  â”‚ #include "doctest.hpp"
  â”‚ #include "core/mailapp.hpp"
  â”‚ #include "core/message.hpp"
  â”‚ 
  â”‚ #include <filesystem>
  â”‚ 
  â”‚ using mail_lib::core::Mailapp;
  â”‚ using mail_lib::core::Message;
  â”‚ 
  â”‚ namespace fs = std::filesystem;
  â”‚ 
  â”‚ TEST_CASE("Enviando mensagem para outro usuÃ¡rio") {
  â”‚   fs::remove_all(STORAGE_DIR"/fake-from");
  â”‚   fs::remove_all(STORAGE_DIR"/fake-to");
  â”‚ 
  â”‚   Mailapp from_app("fake-from");
  â”‚   from_app.send_message("fake-to", "subject", "sending message");
  â”‚ 
  â”‚   Mailapp to_app("fake-to");
  â”‚   Message last_sent = from_app.sent().read_all().back();
  â”‚   Message last_received = to_app.inbox().read_all().back();
  â”‚ 
  â”‚   CHECK_EQ(last_sent.from, "fake-from");
  â”‚   CHECK_EQ(last_sent.to, "fake-to");
  â”‚   CHECK_EQ(last_sent.subject, "subject");
  â”‚   CHECK_EQ(last_sent.content, "sending message");
  â”‚ 
  â”‚   CHECK_EQ(last_received.from, "fake-from");
  â”‚   CHECK_EQ(last_received.to, "fake-to");
  â”‚   CHECK_EQ(last_received.subject, "subject");
  â”‚   CHECK_EQ(last_received.content, "sending message");
  â”‚ }
  â””â”€â”€â”€â”€
  â”Œâ”€â”€â”€â”€
  â”‚ #include "doctest.hpp"
  â”‚ #include "core/message.hpp"
  â”‚ #include "core/mailbox.hpp"
  â”‚ 
  â”‚ #include <vector>
  â”‚ 
  â”‚ using mail_lib::core::Mailbox;
  â”‚ using mail_lib::core::Message;
  â”‚ 
  â”‚ TEST_CASE("Adicionando mensagens Ã  caixa de entrada vazia") {
  â”‚   Mailbox mbox("inbox");
  â”‚   Message msg0 = { "from0", "to0", "content0" };
  â”‚   Message msg1 = { "from1", "to1", "content1" };
  â”‚   mbox.add(msg0).add(msg1);
  â”‚ 
  â”‚   std::vector<Message> msgs = mbox.read_all();
  â”‚ 
  â”‚   auto check_msg = [](Message a, Message b) {
  â”‚     CHECK_EQ(a.from, b.from);
  â”‚     CHECK_EQ(a.to, b.to);
  â”‚     CHECK_EQ(a.content, b.content);
  â”‚   };
  â”‚ 
  â”‚   check_msg(msg0, msgs[0]);
  â”‚   check_msg(msg1, msgs[1]);
  â”‚ }
  â”‚ 
  â”‚ TEST_CASE("Adicionando mensagens Ã  caixa jÃ¡ preenchida") {
  â”‚   std::vector<Message> old_msgs = {{ "from0", "to0", "content0" }};
  â”‚ 
  â”‚   Mailbox mbox("inbox", old_msgs);
  â”‚   mbox.add({ "from1", "to1", "content1" });
  â”‚ 
  â”‚   auto check_msg = [](Message a, Message b) {
  â”‚     CHECK_EQ(a.from, b.from);
  â”‚     CHECK_EQ(a.to, b.to);
  â”‚     CHECK_EQ(a.content, b.content);
  â”‚   };
  â”‚ 
  â”‚   std::vector<Message> msgs = mbox.read_all();
  â”‚ 
  â”‚   check_msg(old_msgs[0], msgs[0]);
  â”‚   check_msg({ "from1", "to1", "content1" } , msgs[1]);
  â”‚ }
  â””â”€â”€â”€â”€
  â”Œâ”€â”€â”€â”€
  â”‚ #include "doctest.hpp"
  â”‚ #include "core/message.hpp"
  â”‚ #include "core/mailbox.hpp"
  â”‚ #include "storage/yaml.hpp"
  â”‚ 
  â”‚ #include <filesystem>
  â”‚ #include <string>
  â”‚ #include <unordered_map>
  â”‚ 
  â”‚ using mail_lib::core::Mailbox;
  â”‚ using mail_lib::core::Message;
  â”‚ 
  â”‚ // Apelido para o namespace (para ficar mais curto)
  â”‚ namespace fs = std::filesystem;
  â”‚ namespace storage = mail_lib::storage;
  â”‚ 
  â”‚ TEST_CASE("YAML") {
  â”‚   std::unordered_map<std::string, Mailbox> mboxes;
  â”‚ 
  â”‚   SUBCASE("Testando o carregamento dos dados: load fake") {
  â”‚     storage::YAML storage("fake-load");
  â”‚     mboxes = storage.load();
  â”‚   }
  â”‚ 
  â”‚   SUBCASE("Testando o salvamento dos dados: store + load") {
  â”‚     fs::remove_all(STORAGE_DIR"/fake-save");
  â”‚     storage::YAML storage("fake-save");
  â”‚     mboxes = storage.save({
  â”‚         Mailbox("inbox")
  â”‚         .add({ "someone0", "fake-user", "subject0", "received0" })
  â”‚         .add({ "someone1", "fake-user", "subject1", "received1" }),
  â”‚ 
  â”‚         Mailbox("sent")
  â”‚         .add({ "fake-user", "someone0", "subject0", "sent0" })
  â”‚         .add({ "fake-user", "someone1", "subject1", "sent1" })
  â”‚       }).load();
  â”‚   }
  â”‚ 
  â”‚   Mailbox &sent = mboxes.at("sent");
  â”‚   std::vector<Message> sent_msgs = sent.read_all();
  â”‚ 
  â”‚   CHECK_EQ(sent.name(), "sent");
  â”‚   CHECK_EQ(sent_msgs[0].from, "fake-user");
  â”‚   CHECK_EQ(sent_msgs[0].to, "someone0");
  â”‚   CHECK_EQ(sent_msgs[0].subject, "subject0");
  â”‚   CHECK_EQ(sent_msgs[0].content, "sent0");
  â”‚ 
  â”‚   CHECK_EQ(sent_msgs[1].from, "fake-user");
  â”‚   CHECK_EQ(sent_msgs[1].to, "someone1");
  â”‚   CHECK_EQ(sent_msgs[1].subject, "subject1");
  â”‚   CHECK_EQ(sent_msgs[1].content, "sent1");
  â”‚ 
  â”‚   auto inbox = mboxes.at("inbox");
  â”‚   auto inbox_msgs = inbox.read_all();
  â”‚ 
  â”‚   CHECK_EQ(inbox.name(), "inbox");
  â”‚   CHECK_EQ(inbox_msgs[0].from, "someone0");
  â”‚   CHECK_EQ(inbox_msgs[0].to, "fake-user");
  â”‚   CHECK_EQ(inbox_msgs[0].subject, "subject0");
  â”‚   CHECK_EQ(inbox_msgs[0].content, "received0");
  â”‚ 
  â”‚   CHECK_EQ(inbox_msgs[1].from, "someone1");
  â”‚   CHECK_EQ(inbox_msgs[1].to, "fake-user");
  â”‚   CHECK_EQ(inbox_msgs[1].subject, "subject1");
  â”‚   CHECK_EQ(inbox_msgs[1].content, "received1");
  â”‚ }
  â””â”€â”€â”€â”€


Do CÃ³digo Fonte ao ExecutÃ¡vel
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  A transformaÃ§Ã£o do cÃ³digo que escrevemos em uma linguagem de
  programaÃ§Ã£o para um programa executÃ¡vel envolve vÃ¡rias fases. No caso
  de C++, estas etapas sÃ£o:

  (1) *PrÃ©-processamento*: nesta fase, todas aquelas macros prefixadas
  com o caractere *#* sÃ£o processadas. Por exemplo, quando o
  prÃ©-processador encontra o comando `#include <iostream>', ele o
  substitui por todo o conteÃºdo do cabeÃ§alho `iostream'.

  Considere o seguinte programa:

  `include/header.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ int sum(int x, int y);
  â””â”€â”€â”€â”€

  `src/header.cpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #include "header.hpp"
  â”‚ int sum(int x, int y) {
  â”‚   return x + y;
  â”‚ }
  â””â”€â”€â”€â”€

  `src/main.cpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #include "header.hpp"
  â”‚ int main() {
  â”‚   return sum(1, 2);
  â”‚ }
  â””â”€â”€â”€â”€

  Para observamos a saÃ­da da fase de prÃ©-processamento, executamos o
  comando

  â”Œâ”€â”€â”€â”€
  â”‚ g++ -std=c++17 -I include/ -E src/main.cpp
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ # 0 "src/main.cpp"
  â”‚ # 0 "<built-in>"
  â”‚ # 0 "<command-line>"
  â”‚ # 1 "/nix/store/hkj250rjsvxcbr31fr1v81cv88cdfp4l-glibc-2.37-8-dev/include/stdc-predef.h" 1 3 4
  â”‚ # 0 "<command-line>" 2
  â”‚ # 1 "src/main.cpp"
  â”‚ # 1 "include/header.hpp" 1
  â”‚        
  â”‚ int sum(int x, int y);
  â”‚ # 2 "src/main.cpp" 2
  â”‚ int main() {
  â”‚   return sum(1, 2);
  â”‚ }
  â””â”€â”€â”€â”€

  (2) *CompilaÃ§Ã£o*: o processo de compilaÃ§Ã£o por si sÃ³ envolve vÃ¡rias
  etapas, como anÃ¡lises sintÃ¡ticas e semÃ¢nticas. O resultado final Ã© o
  cÃ³digo assembly correspondente ao cÃ³digo de entrada. Assembly Ã© uma
  representaÃ§Ã£o humanamente legÃ­vel do cÃ³digo de mÃ¡quina (o formato
  final). Podemos produzir o assembly com o seguinte comando:

  â”Œâ”€â”€â”€â”€
  â”‚ g++ -std=c++17 -I include/ -S src/main.cpp -o build/main.s
  â”‚ cat build/main.s # Para ler o conteÃºdo do arquivo
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ 	.file	"main.cpp"
  â”‚ 	.text
  â”‚ 	.globl	main
  â”‚ 	.type	main, @function
  â”‚ main:
  â”‚ .LFB0:
  â”‚ 	.cfi_startproc
  â”‚ 	pushq	%rbp
  â”‚ 	.cfi_def_cfa_offset 16
  â”‚ 	.cfi_offset 6, -16
  â”‚ 	movq	%rsp, %rbp
  â”‚ 	.cfi_def_cfa_register 6
  â”‚ 	movl	$2, %esi
  â”‚ 	movl	$1, %edi
  â”‚ 	call	_Z3sumii
  â”‚ 	nop
  â”‚ 	popq	%rbp
  â”‚ 	.cfi_def_cfa 7, 8
  â”‚ 	ret
  â”‚ 	.cfi_endproc
  â”‚ .LFE0:
  â”‚ 	.size	main, .-main
  â”‚ 	.ident	"GCC: (GNU) 12.2.0"
  â”‚ 	.section	.note.GNU-stack,"",@progbits
  â””â”€â”€â”€â”€

  (3) *Assembly*: o cÃ³digo no formato assembly Ã© entregue para um
  programa conhecido como /assembler/, que traduz esta representaÃ§Ã£o
  humanamente legÃ­vel para o cÃ³digo de mÃ¡quina. Em C++, chamamos o
  resultado deste processo de arquivo /objeto/. Este ainda nÃ£o Ã© o
  arquivo final, executÃ¡vel. Podemos gerar o arquivo objeto com o
  seguinte comando:

  â”Œâ”€â”€â”€â”€
  â”‚ g++ -std=c++17 -I include/ -c src/main.cpp -o build/main.o
  â””â”€â”€â”€â”€

  (4) *LigaÃ§Ã£o*: vocÃª deve ter reparado que em nenhuma das trÃªs etapas
  acima o arquivo de cÃ³digo `src/header.cpp' foi referenciado. Isto,
  porque as trÃªs etapas anteriores sÃ£o sempre realizadas individualmente
  para cada /unidade de traduÃ§Ã£o/. Uma unidade de traduÃ§Ã£o corresponde
  ao conteÃºdo de Ãºnico arquivo de cÃ³digo (`.cpp') apÃ³s este ter passado
  pela etapa de prÃ©-processamento.

  Quando executamos o comando `g++ -std=c++17 -I include/ src/main.cpp
  src/header.cpp -o bin/main.cpp', implicitamente dois comandos sÃ£o
  executados separadamente:

  â”Œâ”€â”€â”€â”€
  â”‚ g++ -std=c++17 -I include -c src/main.cpp -o build/main.o
  â”‚ g++ -std=c++17 -I include -c src/header.cpp -o build/header.o
  â””â”€â”€â”€â”€

  Este dois arquivos objetos gerados ainda precisam ser conectados, o
  que Ã© feito com o comando

  â”Œâ”€â”€â”€â”€
  â”‚ g++ build/main.o build/header.o -o bin/main
  â””â”€â”€â”€â”€


A ImportÃ¢ncia do Arquivo de CabeÃ§alho em C/C++
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Vimos que Ã© uma boa prÃ¡tica separar declaraÃ§Ãµes (em um arquivo de
  cabeÃ§alho) dos detalhes de implementaÃ§Ã£o (em arquivos de cÃ³digo
  propriamente ditos). Mas, a importÃ¢ncia desta separaÃ§Ã£o nÃ£o Ã©
  meramente organizacional!

  Considere que, ao invÃ©s de separar a implementaÃ§Ã£o da funÃ§Ã£o `sum' em
  um arquivo de cabeÃ§alho e outro de cÃ³digo, a tivÃ©ssemos implementado
  diretamente no arquivo de cabeÃ§alho:

  `include/header_impl.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ int sum(int x, int y) {
  â”‚   return x + y;
  â”‚ }
  â””â”€â”€â”€â”€

  AlÃ©m disso, agora temos dois outros arquivos que usam esta mesma
  funÃ§Ã£o:

  `include/inc.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ #include "header_impl.hpp"
  â”‚ int inc(int x);
  â””â”€â”€â”€â”€

  `src/inc.cpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #include "inc.hpp"
  â”‚ int inc(int x) {
  â”‚   return sum(x, 1);
  â”‚ }
  â””â”€â”€â”€â”€

  `include/triple.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ #include "header_impl.hpp"
  â”‚ int triple(int x);
  â””â”€â”€â”€â”€

  `src/triple.cpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #include "triple.hpp"
  â”‚ int triple(int x) {
  â”‚   return sum(x, sum(x, x));
  â”‚ }
  â””â”€â”€â”€â”€

  E, estamos utilizando ambas as funÃ§Ãµes `inc' e `triple':

  `main.cpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #include "inc.hpp"
  â”‚ #include "triple.hpp"
  â”‚ int main() {
  â”‚   return inc(triple(3));
  â”‚ }
  â””â”€â”€â”€â”€

  Tente compilar este programaâ€¦ vocÃª nÃ£o vai conseguir! Por quÃª?

  Como vimos, os arquivos de cÃ³digo sÃ£o compilados separadamente, e sÃ³
  depois ligados uns aos outros. AlÃ©m disso, na primeira etapa de
  prÃ©-processamento, todo o conteÃºdo de arquivos incluÃ­dos com o comando
  `#include' Ã© copiado diretamente no arquivo que estÃ¡ sendo
  processado. Ou seja, ao final desta etapa existirÃ¡ uma definiÃ§Ã£o para
  a funÃ§Ã£o `sum' no arquivo `inc.cpp' e uma segunda definiÃ§Ã£o da mesma
  funÃ§Ã£o no arquivo `triple.cpp', e o editor de ligaÃ§Ã£o nÃ£o se dÃ¡ bem
  com isso!


Automatizando o Processo de CompilaÃ§Ã£o
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  Vimos que ao executar um comando como `g++ -std=c++17 src0.cpp
  src1.cpp src2.cpp ... -o main' cada um dos arquivos de cÃ³digo Ã©
  compilado individualmente, resultando em arquivos objeto que sÃ³ entÃ£o
  serÃ£o ligados para formar o executÃ¡vel final. O que acontecerÃ¡ caso
  seja realizada alguma alteraÃ§Ã£o em *um* destes arquivos?

  Ao rodar o mesmo comando novamente, *todos* os arquivos serÃ£o
  recompilados, independente se foram alterados ou nÃ£o. NÃ£o queremos
  issoâ€¦

  PoderÃ­amos compilar manualmente cada um destes arquivos em seus
  respectivos objetos, e recompilar apenas os que foram alterados, mas
  seria bastante trabalhoso. Vamos automatizar este processo usando uma
  ferramenta chamada `make'.

  Para tanto, vamos precisar criar um arquivo `Makefile'. Iremos
  implementar neste arquivo todo o processo de compilaÃ§Ã£o.


Conceitos BÃ¡sicos do Makefile
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  O `Makefile' Ã© composto de /alvos/, cada alvo contendo comandos a
  serem executados:

  â”Œâ”€â”€â”€â”€
  â”‚ alvo:
  â”‚         echo "Meu primeiro alvo"
  â”‚         echo "Meu segundo comando"
  â””â”€â”€â”€â”€

  Utilizamos a ferramenta `make' da seguinte forma:

  â”Œâ”€â”€â”€â”€
  â”‚ make alvo
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ echo "Meu primeiro alvo"
  â”‚ Meu primeiro alvo
  â”‚ echo "Meu segundo comando"
  â”‚ Meu segundo comando
  â””â”€â”€â”€â”€


  Por padrÃ£o, o make produz como saÃ­da nÃ£o somente as saÃ­das dos
  comandos executados como tambÃ©m os prÃ³prios comandos. Podemos esconder
  os comandos com um @:

  â”Œâ”€â”€â”€â”€
  â”‚ alvo_sem_echo:
  â”‚         @echo "Meu segundo alvo"
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ make alvo_sem_echo
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ Meu segundo alvo
  â””â”€â”€â”€â”€


  AlÃ©m de comandos, um alvo pode ter /dependÃªncias/. Por exemplo, ao
  executar o alvo `alvo_dependente' a seguir, o alvo `say_hello' irÃ¡
  executar primeiro:

  â”Œâ”€â”€â”€â”€
  â”‚ say_hello:
  â”‚         @echo "Hello"
  â”‚ 
  â”‚ alvo_dependente: say_hello
  â”‚         @echo "Dependente - Sorriso Maroto"
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ make alvo_dependente
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ Hello
  â”‚ Dependente - Sorriso Maroto
  â””â”€â”€â”€â”€


  Por fim, podemos definir /variÃ¡veis/:

  â”Œâ”€â”€â”€â”€
  â”‚ minha_variavel := "variÃ¡vel"
  â”‚ echo_variavel:
  â”‚         @echo "O valor da minha variÃ¡vel Ã©: $(minha_variavel)"
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ make echo_variavel
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ O valor da minha variÃ¡vel Ã©: variÃ¡vel
  â””â”€â”€â”€â”€


Construindo o Makefile da Biblioteca Mail-Lib
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  Vamos comeÃ§ar com a definiÃ§Ã£o de algumas variÃ¡veis:

  â”Œâ”€â”€â”€â”€
  â”‚ # O compilador que vamos utilizar 
  â”‚ CXX := g++
  â”‚ # Algumas flags de compilaÃ§Ã£o
  â”‚ CXXFLAGS := -std=c++17 -Wall -fPIC 
  â”‚ # Flags de inclusÃ£o de cabeÃ§alho	
  â”‚ INCLUDE := -I include/
  â”‚ # Caminho para o doctest
  â”‚ DOCTEST += -I ../
  â”‚ # Nome da pasta onde estÃ£o os cÃ³digos fonte
  â”‚ SRC_DIR := src
  â”‚ # Nome da pasta onde estÃ£o os cÃ³digos de teste
  â”‚ TEST_DIR := test
  â”‚ # Nome da pasta onde serÃ£o armazenados arquivos binÃ¡rios
  â”‚ BIN_DIR := bin
  â”‚ # Nome da pasta onde serÃ£o armazenados arquivos de compilaÃ§Ã£o
  â”‚ BUILD_DIR := build
  â”‚ # Nome da pasta em que serÃ£o armazenadas as caixas de mensagens de cada usuÃ¡rio.
  â”‚ STORAGE_DIR := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))users
  â””â”€â”€â”€â”€

  Agora, vamos definir um alvo para limpar os arquivos de compilaÃ§Ã£o do
  projeto, caso necessÃ¡rio:

  â”Œâ”€â”€â”€â”€
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf $(BUILD_DIR) $(BIN_DIR)
  â””â”€â”€â”€â”€

  E o nosso primeiro alvo para a compilaÃ§Ã£o de um dos arquivos de cÃ³digo
  em objeto:

  â”Œâ”€â”€â”€â”€
  â”‚ $(BUILD_DIR)/$(SRC_DIR)/core/mailbox.o: $(SRC_DIR)/core/mailbox.cpp
  â”‚         @echo "ğŸ›ï¸ Building $(SRC_DIR)/core/mailbox.cpp ..."
  â”‚         @mkdir -p $(BUILD_DIR)/$(SRC_DIR)/core/
  â”‚         @$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" \
  â”‚                 -c $(SRC_DIR)/core/mailbox.cpp \
  â”‚                 -o $(BUILD_DIR)/$(SRC_DIR)/core/mailbox.o
  â””â”€â”€â”€â”€

  Este alvo jÃ¡ Ã© funcional, podemo executÃ¡-lo com o comando `make
  build/src/core/mailbox.o'. Mas, ainda podemos melhorÃ¡-lo bastante.

  Note que o nome do alvo Ã© exatamente o nome do caminho para o arquivo
  objeto. Isto nÃ£o Ã© coincidÃªncia! Podemos acessar o nome do alvo dentro
  da lista de comandos utilizando uma variÃ¡vel especial `$@':

  â”Œâ”€â”€â”€â”€
  â”‚ $(BUILD_DIR)/$(SRC_DIR)/core/mailbox.o: $(SRC_DIR)/core/mailbox.cpp
  â”‚         @echo "ğŸ›ï¸ Building $(SRC_DIR)/core/mailbox.cpp ..."
  â”‚         @mkdir -p $(dir $@)
  â”‚         @$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" \
  â”‚                 -c $(SRC_DIR)/core/mailbox.cpp \
  â”‚                 -o $@
  â””â”€â”€â”€â”€

  De maneira similar, podemos nos referir a *primeira* dependÃªncia do
  alvo atravÃ©s da variÃ¡vel `$<':


  â”Œâ”€â”€â”€â”€
  â”‚ $(BUILD_DIR)/$(SRC_DIR)/core/mailbox.o: $(SRC_DIR)/core/mailbox.cpp
  â”‚         @echo "ğŸ›ï¸ Building $(SRC_DIR)/core/mailbox.cpp ..."
  â”‚         @mkdir -p $(dir $@)
  â”‚         @$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" -c $< -o $@
  â””â”€â”€â”€â”€

  Bem melhor! Temos o nosso primeiro alvo de compilaÃ§Ã£o!

  Mas, e para compilarmos os arquivos restantes? SerÃ¡ que precisamos de
  um alvo para cada arquivo? NÃ£o!

  â”Œâ”€â”€â”€â”€
  â”‚ $(BUILD_DIR)/$(SRC_DIR)/%.o: $(SRC_DIR)/%.cpp
  â”‚         @echo "ğŸ›ï¸ Building $< ..."
  â”‚         @mkdir -p $(dir $@)
  â”‚         @$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" -c $< -o $@
  â””â”€â”€â”€â”€

  O padrÃ£o `%.cpp' irÃ¡ casar com `core/mailapp.cpp', `core/mailbox.cpp',
  e tambÃ©m com `storage/yaml.cpp'. Agora, conseguimos compilar cada um
  dos trÃªs arquivos separadamente.

  Mas, nÃ£o queremos compilar separadamenteâ€¦ queremos compilar a
  biblioteca inteira com um Ãºnico comando! Neste caso em especÃ­fico, o
  resultado da compilaÃ§Ã£o nÃ£o serÃ¡ um executÃ¡vel, mas sim um arquivo
  ".so" (shared object, uma biblioteca).

  Vamos criar um alvo para gerar este arquivo, mas antes precisamos
  coletar todos os arquivos objetos que serÃ£o utilizados:

  â”Œâ”€â”€â”€â”€
  â”‚ SRC_FILES := $(wildcard $(SRC_DIR)/*/*.cpp)
  â”‚ OBJ_SRC_FILES := $(SRC_FILES:.cpp=.o)
  â””â”€â”€â”€â”€

  Agora, podemos criar um alvo para gerar o arquivo da biblioteca (este
  arquivo sempre comeÃ§a com o prefixo `lib'):

  â”Œâ”€â”€â”€â”€
  â”‚ $(BUILD_DIR)/libmail.so: $(addprefix $(BUILD_DIR)/,$(OBJ_SRC_FILES))
  â”‚         @echo "ğŸ”§ Preparing library ..."
  â”‚         @mkdir -p $(BUILD_DIR)
  â”‚         @$(CXX) -shared $^ -o $(BUILD_DIR)/libmail.so
  â””â”€â”€â”€â”€

  Por fim, vamos criar um alvo `build', que depende do arquivo
  `libmail.so':

  â”Œâ”€â”€â”€â”€
  â”‚ build: $(BUILD_DIR)/libmail.so
  â””â”€â”€â”€â”€

  Assim, para compilar o projeto basta utilizar o comando `make
  build'. A ferramenta `make' ainda possui um alvo padrÃ£o, caso nenhum
  seja informado: o primeiro alvo no arquivo. Ou seja, assumindo que o
  alvo `build' Ã© o primeiro que aparece no `Makefile', basta rodar o
  comando `make'.

  Se executarmos o comando `make build' novamente, veremos que nada serÃ¡
  realizado, pois jÃ¡ estÃ¡ tudo atualizado. E, caso faÃ§amos alguma
  alteraÃ§Ã£o em algum arquivo, apenas este arquivo serÃ¡ recompilado.

  No entando, na configuraÃ§Ã£o atual do nosso `Makefile' apenas
  alteraÃ§Ãµes nos arquivos `.cpp' sÃ£o levadas em
  consideraÃ§Ã£o. GostarÃ­amos, tambÃ©m, que alteraÃ§Ãµes nos arquivos `.hpp'
  fossem consideradas (por exemplo, se alterarmos um parÃ¢metro de alguma
  funÃ§Ã£o).

  PrecisarÃ­amos incluir os arquivos de cabeÃ§alho como dependÃªncias do
  alvo de compilaÃ§Ã£o. PorÃ©m, cada arquivo `.cpp' depende de cabeÃ§alhos
  especÃ­ficos, e nÃ£o gostarÃ­amos que uma alteraÃ§Ã£o em um cabeÃ§alho que
  nÃ£o Ã© uma dependÃªncia forÃ§asse recompilaÃ§Ãµes desnecessÃ¡ria.

  Alvos sem nenhum comando podem ser utilizados para adicionar
  dependÃªncias a um alvo existente. Podemos usar isso para adicionar
  dependÃªncias especÃ­ficas de cada arquivo. Por exemplo, para o arquivo
  `src/core/mailbox.cpp':

  â”Œâ”€â”€â”€â”€
  â”‚ $(BUILD_DIR)/$(SRC_DIR)/core/mailbox.o: include/core/mailapp.hpp include/core/message.hpp
  â””â”€â”€â”€â”€

  PorÃ©m, ter que adicionar dependÃªncias manualmente vai contra a ideia
  de um Ãºnico alvo para mÃºltiplos arquivosâ€¦

  Felizmente, podemos utilizar o compilador g++ para gerar arquivos de
  dependÃªncias (como acima), e incluÃ­-los no makefile. Basta adicionar
  as opÃ§Ãµes `-MMD -MP' ao comando de compilaÃ§Ã£o, e incluir os arquivos
  `.d' gerados no Makefile:

  â”Œâ”€â”€â”€â”€
  â”‚ DEP_FILES := $(SRC_FILES:.cpp=.d)
  â”‚ -include $(addprefix $(BUILD_DIR)/,$(DEP_FILES))
  â”‚ 
  â”‚ $(BUILD_DIR)/$(SRC_DIR)/%.o: $(SRC_DIR)/%.cpp
  â”‚         @echo "ğŸ›ï¸ Building $< ..."
  â”‚         @mkdir -p $(dir $@)
  â”‚         @$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" -MMD -MP -c $< -o $@
  â””â”€â”€â”€â”€

  O arquivo Makefile final, incluindo a parte de testes:

  â”Œâ”€â”€â”€â”€
  â”‚ CXX := g++
  â”‚ CXXFLAGS := -std=c++17 -Wall -fPIC
  â”‚ 
  â”‚ INCLUDE := -I include/
  â”‚ DOCTEST += -I ../ # doctest (nÃ£o Ã© o melhor lugar...)
  â”‚ 
  â”‚ SRC_DIR := src
  â”‚ TEST_DIR := test
  â”‚ 
  â”‚ BIN_DIR := bin
  â”‚ BUILD_DIR := build
  â”‚ 
  â”‚ STORAGE_DIR := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))users
  â”‚ 
  â”‚ define fake_inbox =
  â”‚ - from: "someone0"
  â”‚   to: "fake-user"
  â”‚   subject: "subject0"
  â”‚   content: "received0"
  â”‚ - from: "someone1"
  â”‚   to: "fake-user"
  â”‚   subject: "subject1"
  â”‚   content: "received1"
  â”‚ endef
  â”‚ export fake_inbox
  â”‚ 
  â”‚ define fake_sent =
  â”‚ - from: "fake-user"
  â”‚   to: "someone0"
  â”‚   subject: "subject0"
  â”‚   content: "sent0"
  â”‚ - from: "fake-user"
  â”‚   to: "someone1"
  â”‚   subject: "subject1"
  â”‚   content: "sent1"
  â”‚ endef
  â”‚ export fake_sent
  â”‚ 
  â”‚ SRC_FILES := $(wildcard $(SRC_DIR)/*/*.cpp)
  â”‚ TEST_FILES := $(wildcard $(TEST_DIR)/*.cpp $(TEST_DIR)/*/*.cpp)
  â”‚ 
  â”‚ DEP_FILES := $(SRC_FILES:.cpp=.d)
  â”‚ DEP_FILES += $(TEST_FILES:.cpp=.d)
  â”‚ 
  â”‚ OBJ_SRC_FILES := $(SRC_FILES:.cpp=.o)
  â”‚ OBJ_TEST_FILES := $(OBJ_SRC_FILES)
  â”‚ OBJ_TEST_FILES += $(TEST_FILES:.cpp=.o)
  â”‚ 
  â”‚ -include $(addprefix $(BUILD_DIR)/,$(DEP_FILES))
  â”‚ 
  â”‚ build: $(BUILD_DIR)/libmail.so
  â”‚ 
  â”‚ $(BUILD_DIR)/libmail.so: $(addprefix $(BUILD_DIR)/,$(OBJ_SRC_FILES))
  â”‚         @echo "ğŸ”§ Preparing library ..."
  â”‚         @mkdir -p $(BUILD_DIR)
  â”‚         @$(CXX) -shared $^ -o $(BUILD_DIR)/libmail.so
  â”‚ 
  â”‚ test: $(BIN_DIR)/test
  â”‚         @$(BIN_DIR)/test
  â”‚ 
  â”‚ $(BIN_DIR)/test: $(addprefix $(BUILD_DIR)/,$(OBJ_TEST_FILES))
  â”‚         @echo "ğŸ”§ Preparing test suite ..."
  â”‚         @mkdir -p $(BIN_DIR)
  â”‚         @$(CXX) $(CXXFLAGS) $^ -o $@
  â”‚ 
  â”‚ $(BUILD_DIR)/$(SRC_DIR)/%.o: $(SRC_DIR)/%.cpp
  â”‚         @echo "ğŸ›ï¸ Building $< ..."
  â”‚         @mkdir -p $(dir $@)
  â”‚         @$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" -MMD -MP -c $< -o $@
  â”‚ 
  â”‚ $(BUILD_DIR)/$(TEST_DIR)/%.o: $(TEST_DIR)/%.cpp
  â”‚         @echo "ğŸ›ï¸ Building $< ..."
  â”‚         @mkdir -p $(dir $@)
  â”‚         @mkdir -p $(STORAGE_DIR)/fake-load
  â”‚         @echo "$$fake_inbox" > $(STORAGE_DIR)/fake-load/inbox.yaml
  â”‚         @echo "$$fake_sent" > $(STORAGE_DIR)/fake-load/sent.yaml
  â”‚         @$(CXX) $(CXXFLAGS) $(INCLUDE) $(DOCTEST) -D STORAGE_DIR=\"$(STORAGE_DIR)\" -MMD -MP -c $< -o $@
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf $(BUILD_DIR) $(BIN_DIR)
  â””â”€â”€â”€â”€
