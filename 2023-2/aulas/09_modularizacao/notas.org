#+title: Notas de Aula - 09 Modulariza√ß√£o
#+author: Luigi D. C. Soares
#+startup: entitiespretty
#+options: toc:nil  num:nil
* Programa√ß√£o Modular

- O que √©?
  
  "software design technique that emphasizes separating the functionality of a program into *independent*, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality"
  
  (https://en.wikipedia.org/wiki/Modular_programming)
  
- Quando/por qu√™ utilizar?

Queremos agrupar elementos que dizem respeito a uma mesma funcionalidade. Onde j√° vimos isso?

- Classes: agrupamento local (campos)

Ainda assim, classes representam algo bem espec√≠fico (lembram do princ√≠pio de responsabilidade √∫nica? SRP), o que n√£o √© suficiente a medida que o sistema cresce e se torna mais complexo.

Classes possuem diversas rela√ß√µes entre si (voltaremos nisso). Algumas classes est√£o muito "pr√≥ximas", outras mais distantes. Como organiz√°-las? Qual o pr√≥ximo passo?

M√≥dulos!
- Independente (na medida do poss√≠vel... depend√™ncias restritas as interfaces de outros m√≥dulos)
- Reutiliz√°vel e modific√°vel
- SRP ainda se aplica
- Coes√£o: grau de depend√™ncia entre os elementos do m√≥dulo (queremos *alta coes√£o*)
- Acoplamento: grau de depend√™ncia entre diferentes m√≥dulos (queremos *baixo acoplamento*)

E como representar m√≥dulos em C++? Isto √©, como agrupar classes/funcionalidades?

* Namespaces

- Onde j√° vimos isso? ~std::~
- E como podemos criar nossos pr√≥prios namespaces?
  
=message.hpp=

#+begin_src C++
#pragma once

namespace mail_lib {
struct Message {
  std::string from;
  std::string to;
  std::string subject;
  std::string content;
};
}
#+end_src

=mailbox.hpp=

#+begin_src C++
#pragma once

namespace mail_lib {
class Mailbox { ... };
}
#+end_src

- E como utilizar?

#+begin_src C++
mail_lib::Message msg;
mail_lib::Mailbox mbox;
#+end_src

- Podemos, inclusive, concatenar espa√ßos de nome:

=mailbox.hpp=

#+begin_src C++
#pragma once

namespace mail_lib::core {
class Mailbox { ... };
}
#+end_src

=yaml.hpp=

#+begin_src C++
#pragma once

namespace mail_lib::storage {
class YAML { ... };
}
#+end_src

- E para usar:

#+begin_src C++
mail_lib::core::Mailbox mbox;
mail_lib::storage::YAML storage;
#+end_src

- Ou podemos "renomear":

#+begin_src C++
namespace core = mail_lib::core;
namespace storage = mail_lib::storage;

core::Mailbox mbox;
storage::YAML storage;
#+end_src

- =mail_lib= aqui est√° servindo como o espa√ßo de nomes da nossa biblioteca como um todo (que veremos a seguir)
- =mail_lib::core= √© o m√≥dulo que agrupa as funcionalidades relacionadas ao sistema de emails
- =mail_lib::storage= √© o m√≥dulo que agrupa as funcionalidades relacionadas ao armazenamento dos dados
  
* Organiza√ß√£o do Projeto

A forma como estruturamos nosso projeto tamb√©m √© importante!

Nosso primeiro mini-projeto: uma biblioteca para gerenciamento de um sistema de emails

A estrutura do projeto:

#+begin_example
mail-lib/
|__ bin/
|__ build/
|__ doc/
|__ include/
    |__ core/
        |__ mailapp.hpp
        |__ mailbox.hpp
        |__ message.hpp
    |__ storage/
        |__ yaml.hpp
|__ src/
    |__ core/
        |__ mailapp.cpp
        |__ mailbox.cpp
    |__ storage/
        |__ yaml.cpp
|__ test/
    |__ core/
        |__ mailapp.cpp
        |__ mailbox.cpp
    |__ storage/
        |__ yaml.cpp
        |__ driver.cpp
|__ Doxyfile
|__ Makefile
#+end_example

Temos um m√≥dulo ~mail_lib::core~ agrupando as funcionalidades de ~Message~, ~Mailbox~, e ~Mailapp~:

#+html: <details>
#+html: <summary>include/core/message.hpp (clique aqui)</summary>
#+begin_src C++
#pragma once

#include <string>

namespace mail_lib::core {
struct Message {
  std::string from;
  std::string to;
  std::string subject;
  std::string content;
};
}
#+end_src
#+html: </details>

#+html: <details>
#+html: <summary>include/core/mailbox.hpp (clique aqui)</summary>
#+begin_src C++
#pragma once

#include "message.hpp"

#include <string>
#include <vector>

namespace mail_lib::core {
class Mailbox {
public:
  /// @brief Inicializa a caixa com um determinado nome, mas vazia
  ///
  /// Detalhes...
  /// @param name Nome da caixa de mensagens (e.g., inbox)
  Mailbox(std::string name);

  /// @brief Inicializa a caixa com mensagens previamente lidas
  /// @param name Nome da caixa de mensagens (e.g., inbox)
  /// @param msgs Vetor de mensagens, onde a **√∫ltima** deve ser
  ///             a mais recente (idealmente teria um timestamp...)
  Mailbox(std::string name, std::vector<Message> const &msgs);

  /// @brief Adiciona uma mensagem ao final da lista
  /// @param msg Mensagem a ser adicionada
  /// @return A pr√≥pria caixa, para chamadas consecutivas
  Mailbox &add(Message msg);

  /// @return A lista de mensagens, em que o √∫ltimo elemento √©
  ///         a mensagem adicionada mais recentemente
  std::vector<Message> read_all() const;

  /// @return Nome da caixa de entrada
  std::string name() const;
  
private:
  std::string _name;
  std::vector<Message> _msgs;
};
};
#+end_src
#+html: </details>

#+html: <details>
#+html: <summary>src/core/mailbox.cpp (clique aqui)</summary>
#+begin_src C++
#include "mailbox.hpp"
#include "message.hpp"

#include <vector>

namespace mail_lib::core {
Mailbox::Mailbox(std::string name, std::vector<Message> const &msgs) {
  _name = name;
  _msgs = msgs;
}

Mailbox::Mailbox(std::string name) : Mailbox(name, {}) {}


Mailbox &Mailbox::add(Message msg) {
  _msgs.push_back(msg);
  return *this;
}

std::vector<Message> Mailbox::read_all() const {
  return _msgs;
}

std::string Mailbox::name() const {
  return _name;
}
}
#+end_src
#+html: </details>

#+html: <details>
#+html: <summary>include/core/mailapp.hpp (clique aqui)</summary>
#+begin_src C++
#pragma once

#include "mailbox.hpp"
#include "message.hpp"
#include "yaml.hpp"

namespace mail_lib::core {
class Mailapp {
public:
  /// @brief Inicializa√ß√£o das caixas de entrada e sa√≠da
  ///
  /// Busca as mensagens lidas e enviadas pelo usu√°rio,
  /// para inicializar as caixas de mensagens.
  ///
  /// FIXME: obviamente, aqui (ou em algum passo antes)
  ///        deveria ter alguma etapa de autentica√ß√£o...
  ///
  /// @param user Usu√°rio (email) que est√° logado
  Mailapp(std::string user);

  /// @brief Realiza o flush das caixas de mensagem
  ~Mailapp();

  /// @return A caixa de entrada, para leitura de emails recebidos
  Mailbox inbox() const;

  /// @return A caixa de sa√≠da, para leitura de emails enviados
  Mailbox sent() const;

  /// @brief Adiciona nova mensagem √† caixa de sa√≠da
  Mailapp &send_message(std::string to, std::string subject, std::string content);

private:
  std::string _user;
  
  Mailbox _inbox = Mailbox("inbox");
  Mailbox _sent = Mailbox("sent");

  unsigned _start_new_inbox = 0;
  unsigned _start_new_sent = 0;
  
  storage::YAML _user_storage;
};
}
#+end_src
#+html: </details>

#+html: <details>
#+html: <summary>src/core/mailapp.cpp (clique aqui)</summary>
#+begin_src C++
#include "mailapp.hpp"
#include "mailbox.hpp"
#include "yaml.hpp"
#include <iostream>

namespace mail_lib::core {
Mailapp::Mailapp(std::string user) : _user(user), _user_storage(user) {
  auto mboxes = _user_storage.load();

  auto inbox_it = mboxes.find("inbox");
  if (inbox_it != mboxes.end()) {
    _inbox = inbox_it->second;
    _start_new_inbox = _inbox.read_all().size();
  }
  
  auto sent_it = mboxes.find("sent");
  if (sent_it != mboxes.end()) {
    _sent = sent_it->second;
    _start_new_sent = _sent.read_all().size();
  }
}

Mailapp::~Mailapp() {
  Mailbox new_inbox("inbox");
  auto inbox_msgs = _inbox.read_all();
  for (unsigned i = _start_new_inbox; i < inbox_msgs.size(); i++) {
    new_inbox.add(inbox_msgs[i]);
  }
  
  Mailbox new_sent("sent");
  auto sent_msgs = _sent.read_all();
  for (unsigned i = _start_new_sent; i < sent_msgs.size(); i++) {
    new_sent.add(sent_msgs[i]);
  }
  
  _user_storage.save({new_inbox, new_sent});
}

Mailbox Mailapp::inbox() const {
  return _inbox;
}

Mailbox Mailapp::sent() const {
  return _sent;
}

Mailapp &Mailapp::send_message(std::string to, std::string subject, std::string content) {
  Message m = {_user, to, subject, content};
  _sent.add(m);
  
  // Aqui estamos acessando a pasta de um usu√°rio n√£o autenticado,
  // poss√≠vel fonte de problemas/ataques...
  // Mas √© s√≥ um exemplo para as aulas, ent√£o vamos simplificar;
  storage::YAML(to).save({ Mailbox("inbox").add(m) });

  return *this;
}
}
#+end_src
#+html: </details>

E temos o m√≥dulo ~mail_lib::storage~, composto pela classe ~YAML~:

#+html: <details>
#+html: <summary>include/storage/yaml.hpp (clique aqui)</summary>
#+begin_src C++
#pragma once

#include "mailbox.hpp"

#include <fstream>
#include <unordered_map>
#include <string>

namespace mail_lib::storage {
class YAML {
public:
  /// @brief Inicializa o gerenciador YAML das caixas do usu√°rio
  ///
  /// O diret√≥rio do usu√°rio √© criado vazio, caso n√£o exista
  YAML(std::string user);

  /// TODO: poderia verificar se os arquivos n√£o foram alterados,
  ///       para evitar loads em sequ√™ncia...
  /// @return Lista de mailboxes do usu√°rio
  std::unordered_map<std::string, core::Mailbox> load();

  /// @brief Persiste as mailboxes nos arquivos do usu√°rio.
  YAML &save(std::vector<core::Mailbox> const &mboxes);

private:
  std::string _user_path;
  std::unordered_map<std::string, std::fstream> _user_files;
};
}
#+end_src
#+html: </details>

#+html: <details>
#+html: <summary>src/storage/yaml.cpp (clique aqui)</summary>
#+begin_src C++
#include "yaml.hpp"
#include "mailbox.hpp"

#include <filesystem>
#include <iomanip>
#include <sstream>
#include <string>
#include <unordered_map>

namespace fs = std::filesystem;

namespace mail_lib::storage {
YAML::YAML(std::string user) {
  _user_path = STORAGE_DIR"/" + user + "/";
  fs::create_directory(_user_path); // Cria diret√≥rio, se n√£o existe
  
  for (auto const &entry : fs::directory_iterator(_user_path)) {
    auto const &file_path = entry.path();
    auto file_mode = std::fstream::in | std::fstream::out | std::fstream::app;
    _user_files[file_path.stem()] = std::fstream(file_path.c_str(), file_mode);
  }
}

std::unordered_map<std::string, core::Mailbox> YAML::load() {
  std::unordered_map<std::string, core::Mailbox> mboxes;
  for (auto &file : _user_files) {
    std::string filename = file.first;
    std::fstream &fs = file.second;
    std::string item;
    
    std::vector<core::Message> msgs;
    fs.seekg(std::ios::beg);
    
    while (std::getline(fs, item)) {
      core::Message msg;

      std::istringstream stream(item.substr(item.find(":") + 2));
      stream >> std::quoted(msg.from);

      std::getline(fs, item);
      stream.str(item.substr(item.find(":") + 2));
      stream >> std::quoted(msg.to);
      
      std::getline(fs, item);
      stream.str(item.substr(item.find(":") + 2));
      stream >> std::quoted(msg.subject);
      
      std::getline(fs, item);
      stream.str(item.substr(item.find(":") + 2));
      stream >> std::quoted(msg.content);

      msgs.push_back(msg);
    }
    mboxes.try_emplace(filename, filename, msgs);
  }
  return mboxes;
}

YAML &YAML::save(std::vector<core::Mailbox> const &mboxes) {
  for (core::Mailbox const &mbox: mboxes) {
    std::string filename = mbox.name();
    
    if (!_user_files.count(filename)) {
      auto file_mode = std::fstream::in | std::fstream::out | std::fstream::app;
      _user_files[filename] = std::fstream(_user_path + filename + ".yaml", file_mode);
    }
    
    std::fstream &fs = _user_files[filename];
    for (core::Message const &msg : mbox.read_all()) {
      fs << "- from: \"" << msg.from << "\"" << std::endl;;
      fs << "  to: \"" << msg.to << "\"" << std::endl;
      fs << "  subject: \"" << msg.subject << "\"" << std::endl;
      fs << "  content: \"" << msg.content << "\"" << std::endl;
    }
  }
  return *this;
}
}
#+end_src
#+html: </details>

Por fim, temos tamb√©m os testes para cada uma das classes, tamb√©m organizados pelos m√≥dulos:

#+html: <details>
#+html: <summary>test/driver.cpp (clique aqui)</summary>
#+begin_src C++
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest.hpp>
#+end_src
#+html: </details>

#+html: <details>
#+html: <summary>test/core/mailapp.cpp (clique aqui)</summary>
#+begin_src C++
#include "doctest.hpp"
#include "core/mailapp.hpp"
#include "core/message.hpp"

#include <filesystem>

using mail_lib::core::Mailapp;
using mail_lib::core::Message;

namespace fs = std::filesystem;

TEST_CASE("Enviando mensagem para outro usu√°rio") {
  fs::remove_all(STORAGE_DIR"/fake-from");
  fs::remove_all(STORAGE_DIR"/fake-to");
  
  Mailapp from_app("fake-from");
  from_app.send_message("fake-to", "subject", "sending message");

  Mailapp to_app("fake-to");
  Message last_sent = from_app.sent().read_all().back();
  Message last_received = to_app.inbox().read_all().back();

  CHECK_EQ(last_sent.from, "fake-from");
  CHECK_EQ(last_sent.to, "fake-to");
  CHECK_EQ(last_sent.subject, "subject");
  CHECK_EQ(last_sent.content, "sending message");
  
  CHECK_EQ(last_received.from, "fake-from");
  CHECK_EQ(last_received.to, "fake-to");
  CHECK_EQ(last_received.subject, "subject");
  CHECK_EQ(last_received.content, "sending message");
}
#+end_src
#+html: </details>

#+html: <details>
#+html: <summary>test/core/mailbox.cpp (clique aqui)</summary>
#+begin_src C++
#include "doctest.hpp"
#include "core/message.hpp"
#include "core/mailbox.hpp"

#include <vector>

using mail_lib::core::Mailbox;
using mail_lib::core::Message;

TEST_CASE("Adicionando mensagens √† caixa de entrada vazia") {
  Mailbox mbox("inbox");
  Message msg0 = { "from0", "to0", "content0" };
  Message msg1 = { "from1", "to1", "content1" };
  mbox.add(msg0).add(msg1);

  std::vector<Message> msgs = mbox.read_all();

  auto check_msg = [](Message a, Message b) {
    CHECK_EQ(a.from, b.from);
    CHECK_EQ(a.to, b.to);
    CHECK_EQ(a.content, b.content);
  };

  check_msg(msg0, msgs[0]);
  check_msg(msg1, msgs[1]);
}

TEST_CASE("Adicionando mensagens √† caixa j√° preenchida") {
  std::vector<Message> old_msgs = {{ "from0", "to0", "content0" }};
  
  Mailbox mbox("inbox", old_msgs);
  mbox.add({ "from1", "to1", "content1" });

  auto check_msg = [](Message a, Message b) {
    CHECK_EQ(a.from, b.from);
    CHECK_EQ(a.to, b.to);
    CHECK_EQ(a.content, b.content);
  };

  std::vector<Message> msgs = mbox.read_all();
  
  check_msg(old_msgs[0], msgs[0]);
  check_msg({ "from1", "to1", "content1" } , msgs[1]);
}
#+end_src
#+html: </details>

#+html: <details>
#+html: <summary>test/storage/yaml.cpp (clique aqui)</summary>
#+begin_src C++
#include "doctest.hpp"
#include "core/message.hpp"
#include "core/mailbox.hpp"
#include "storage/yaml.hpp"

#include <filesystem>
#include <string>
#include <unordered_map>

using mail_lib::core::Mailbox;
using mail_lib::core::Message;

// Apelido para o namespace (para ficar mais curto)
namespace fs = std::filesystem;
namespace storage = mail_lib::storage;

TEST_CASE("YAML") {
  std::unordered_map<std::string, Mailbox> mboxes;

  SUBCASE("Testando o carregamento dos dados: load fake") {
    storage::YAML storage("fake-load");
    mboxes = storage.load();
  }

  SUBCASE("Testando o salvamento dos dados: store + load") {
    fs::remove_all(STORAGE_DIR"/fake-save");
    storage::YAML storage("fake-save");
    mboxes = storage.save({
	Mailbox("inbox")
	.add({ "someone0", "fake-user", "subject0", "received0" })
	.add({ "someone1", "fake-user", "subject1", "received1" }),
	
	Mailbox("sent")
	.add({ "fake-user", "someone0", "subject0", "sent0" })
	.add({ "fake-user", "someone1", "subject1", "sent1" })
      }).load();
  }
  
  Mailbox &sent = mboxes.at("sent");
  std::vector<Message> sent_msgs = sent.read_all();
  
  CHECK_EQ(sent.name(), "sent");
  CHECK_EQ(sent_msgs[0].from, "fake-user");
  CHECK_EQ(sent_msgs[0].to, "someone0");
  CHECK_EQ(sent_msgs[0].subject, "subject0");
  CHECK_EQ(sent_msgs[0].content, "sent0");
  
  CHECK_EQ(sent_msgs[1].from, "fake-user");
  CHECK_EQ(sent_msgs[1].to, "someone1");
  CHECK_EQ(sent_msgs[1].subject, "subject1");
  CHECK_EQ(sent_msgs[1].content, "sent1");

  auto inbox = mboxes.at("inbox");
  auto inbox_msgs = inbox.read_all();
  
  CHECK_EQ(inbox.name(), "inbox");
  CHECK_EQ(inbox_msgs[0].from, "someone0");
  CHECK_EQ(inbox_msgs[0].to, "fake-user");
  CHECK_EQ(inbox_msgs[0].subject, "subject0");
  CHECK_EQ(inbox_msgs[0].content, "received0");
  
  CHECK_EQ(inbox_msgs[1].from, "someone1");
  CHECK_EQ(inbox_msgs[1].to, "fake-user");
  CHECK_EQ(inbox_msgs[1].subject, "subject1");
  CHECK_EQ(inbox_msgs[1].content, "received1");
}
#+end_src
#+html: </details>

* Do C√≥digo Fonte ao Execut√°vel

A transforma√ß√£o do c√≥digo que escrevemos em uma linguagem de programa√ß√£o para um programa execut√°vel envolve v√°rias fases. No caso de C++, estas etapas s√£o:

(1) *Pr√©-processamento*: nesta fase, todas aquelas macros prefixadas com o caractere *#* s√£o processadas. Por exemplo, quando o pr√©-processador encontra o comando ~#include <iostream>~, ele o substitui por todo o conte√∫do do cabe√ßalho ~iostream~.

Considere o seguinte programa:

=include/header.hpp=

#+begin_src C++ :exports code :tangle include/header.hpp :main no
#pragma once
int sum(int x, int y);
#+end_src

=src/header.cpp=

#+begin_src C++ :exports code :tangle src/header.cpp :main no
#include "header.hpp"
int sum(int x, int y) {
  return x + y;
}
#+end_src

=src/main.cpp=

#+begin_src C++ :exports code :tangle src/main.cpp
#include "header.hpp"
int main() {
  return sum(1, 2);
}
#+end_src

Para observamos a sa√≠da da fase de pr√©-processamento, executamos o comando

#+begin_src sh :exports both :results scalar
g++ -std=c++17 -I include/ -E src/main.cpp
#+end_src

#+RESULTS:
#+begin_example
# 0 "src/main.cpp"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/nix/store/hkj250rjsvxcbr31fr1v81cv88cdfp4l-glibc-2.37-8-dev/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "src/main.cpp"
# 1 "include/header.hpp" 1
       
int sum(int x, int y);
# 2 "src/main.cpp" 2
int main() {
  return sum(1, 2);
}
#+end_example

(2) *Compila√ß√£o*: o processo de compila√ß√£o por si s√≥ envolve v√°rias etapas, como an√°lises sint√°ticas e sem√¢nticas. O resultado final √© o c√≥digo assembly correspondente ao c√≥digo de entrada. Assembly √© uma representa√ß√£o humanamente leg√≠vel do c√≥digo de m√°quina (o formato final). Podemos produzir o assembly com o seguinte comando:

#+begin_src sh :exports both :results scalar
g++ -std=c++17 -I include/ -S src/main.cpp -o build/main.s
cat build/main.s # Para ler o conte√∫do do arquivo
#+end_src

#+RESULTS:
#+begin_example
	.file	"main.cpp"
	.text
	.globl	main
	.type	main, @function
main:
.LFB0:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$2, %esi
	movl	$1, %edi
	call	_Z3sumii
	nop
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
.LFE0:
	.size	main, .-main
	.ident	"GCC: (GNU) 12.2.0"
	.section	.note.GNU-stack,"",@progbits
#+end_example

(3) *Assembly*: o c√≥digo no formato assembly √© entregue para um programa conhecido como /assembler/, que traduz esta representa√ß√£o humanamente leg√≠vel para o c√≥digo de m√°quina. Em C++, chamamos o resultado deste processo de arquivo /objeto/. Este ainda n√£o √© o arquivo final, execut√°vel. Podemos gerar o arquivo objeto com o seguinte comando:

#+begin_src sh :exports code :results none
g++ -std=c++17 -I include/ -c src/main.cpp -o build/main.o
#+end_src

(4) *Liga√ß√£o*: voc√™ deve ter reparado que em nenhuma das tr√™s etapas acima o arquivo de c√≥digo =src/header.cpp= foi referenciado. Isto, porque as tr√™s etapas anteriores s√£o sempre realizadas individualmente para cada /unidade de tradu√ß√£o/. Uma unidade de tradu√ß√£o corresponde ao conte√∫do de √∫nico arquivo de c√≥digo (=.cpp=) ap√≥s este ter passado pela etapa de pr√©-processamento.

Quando executamos o comando =g++ -std=c++17 -I include/ src/main.cpp src/header.cpp -o bin/main.cpp=, implicitamente dois comandos s√£o executados separadamente:

#+begin_src sh :exports code :results none
g++ -std=c++17 -I include -c src/main.cpp -o build/main.o
g++ -std=c++17 -I include -c src/header.cpp -o build/header.o
#+end_src

Este dois arquivos objetos gerados ainda precisam ser conectados, o que √© feito com o comando

#+begin_src sh :exports code :results none
g++ build/main.o build/header.o -o bin/main
#+end_src

** A Import√¢ncia do Arquivo de Cabe√ßalho em C/C++

Vimos que √© uma boa pr√°tica separar declara√ß√µes (em um arquivo de cabe√ßalho) dos detalhes de implementa√ß√£o (em arquivos de c√≥digo propriamente ditos). Mas, a import√¢ncia desta separa√ß√£o n√£o √© meramente organizacional!

Considere que, ao inv√©s de separar a implementa√ß√£o da fun√ß√£o ~sum~ em um arquivo de cabe√ßalho e outro de c√≥digo, a tiv√©ssemos implementado diretamente no arquivo de cabe√ßalho:

=include/header_impl.hpp=

#+begin_src C++ :exports code :tangle include/header_impl.hpp :main no
#pragma once
int sum(int x, int y) {
  return x + y;
}
#+end_src

Al√©m disso, agora temos dois outros arquivos que usam esta mesma fun√ß√£o:

=include/inc.hpp=

#+begin_src C++ :exports code :tangle include/inc.hpp :main no
#pragma once
#include "header_impl.hpp"
int inc(int x);
#+end_src

=src/inc.cpp=

#+begin_src C++ :exports code :tangle src/inc.cpp :main no
#include "inc.hpp"
int inc(int x) {
  return sum(x, 1);
}
#+end_src

=include/triple.hpp=

#+begin_src C++ :exports code :tangle include/triple.hpp :main no
#pragma once
#include "header_impl.hpp"
int triple(int x);
#+end_src

=src/triple.cpp=

#+begin_src C++ :exports code :tangle src/triple.cpp :main no
#include "triple.hpp"
int triple(int x) {
  return sum(x, sum(x, x));
}
#+end_src

E, estamos utilizando ambas as fun√ß√µes ~inc~ e ~triple~:

=main.cpp=

#+begin_src C++ :exports code :flags -I include/ src/inc.cpp src/triple.cpp :results none
#include "inc.hpp"
#include "triple.hpp"
int main() {
  return inc(triple(3));
}
#+end_src

Tente compilar este programa... voc√™ n√£o vai conseguir! Por qu√™?

Como vimos, os arquivos de c√≥digo s√£o compilados separadamente, e s√≥ depois ligados uns aos outros. Al√©m disso, na primeira etapa de pr√©-processamento, todo o conte√∫do de arquivos inclu√≠dos com o comando ~#include~ √© copiado diretamente no arquivo que est√° sendo processado. Ou seja, ao final desta etapa existir√° uma defini√ß√£o para a fun√ß√£o ~sum~ no arquivo ~inc.cpp~ e uma segunda defini√ß√£o da mesma fun√ß√£o no arquivo ~triple.cpp~, e o editor de liga√ß√£o n√£o se d√° bem com isso!

* Automatizando o Processo de Compila√ß√£o

Vimos que ao executar um comando como ~g++ -std=c++17 src0.cpp src1.cpp src2.cpp ... -o main~ cada um dos arquivos de c√≥digo √© compilado individualmente, resultando em arquivos objeto que s√≥ ent√£o ser√£o ligados para formar o execut√°vel final. O que acontecer√° caso seja realizada alguma altera√ß√£o em *um* destes arquivos?

Ao rodar o mesmo comando novamente, *todos* os arquivos ser√£o recompilados, independente se foram alterados ou n√£o. N√£o queremos isso...

Poder√≠amos compilar manualmente cada um destes arquivos em seus respectivos objetos, e recompilar apenas os que foram alterados, mas seria bastante trabalhoso. Vamos automatizar este processo usando uma ferramenta chamada =make=.

Para tanto, vamos precisar criar um arquivo =Makefile=. Iremos implementar neste arquivo todo o processo de compila√ß√£o.

** Conceitos B√°sicos do Makefile

O =Makefile= √© composto de /alvos/, cada alvo contendo comandos a serem executados:

#+begin_src makefile :tangle Makefile
alvo:
	echo "Meu primeiro alvo"
	echo "Meu segundo comando"
#+end_src

Utilizamos a ferramenta =make= da seguinte forma:

#+begin_src sh :exports both :results scalar
make alvo
#+end_src

#+RESULTS:
: echo "Meu primeiro alvo"
: Meu primeiro alvo
: echo "Meu segundo comando"
: Meu segundo comando

Por padr√£o, o make produz como sa√≠da n√£o somente as sa√≠das dos comandos executados como tamb√©m os pr√≥prios comandos. Podemos esconder os comandos com um @:

#+begin_src makefile :tangle Makefile
alvo_sem_echo:
	@echo "Meu segundo alvo"
#+end_src

#+begin_src sh :exports both :results scalar
make alvo_sem_echo
#+end_src

#+RESULTS:
: Meu segundo alvo

Al√©m de comandos, um alvo pode ter /depend√™ncias/. Por exemplo, ao executar o alvo ~alvo_dependente~ a seguir, o alvo ~say_hello~ ir√° executar primeiro:

#+begin_src makefile :tangle Makefile
say_hello:
	@echo "Hello"

alvo_dependente: say_hello
	@echo "Dependente - Sorriso Maroto"
#+end_src

#+begin_src sh :exports both :results scalar
make alvo_dependente
#+end_src

#+RESULTS:
: Hello
: Dependente - Sorriso Maroto

Por fim, podemos definir /vari√°veis/:

#+begin_src makefile :tangle Makefile
minha_variavel := "vari√°vel"
echo_variavel:
	@echo "O valor da minha vari√°vel √©: $(minha_variavel)"
#+end_src

#+begin_src sh :exports both :results scalar
make echo_variavel
#+end_src

#+RESULTS:
: O valor da minha vari√°vel √©: vari√°vel

** Construindo o Makefile da Biblioteca Mail-Lib

Vamos come√ßar com a defini√ß√£o de algumas vari√°veis:

#+begin_src makefile
# O compilador que vamos utilizar 
CXX := g++
# Algumas flags de compila√ß√£o
CXXFLAGS := -std=c++17 -Wall -fPIC 
# Flags de inclus√£o de cabe√ßalho	
INCLUDE := -I include/
# Nome da pasta onde est√£o os c√≥digos fonte
SRC_DIR := src
# Nome da pasta onde ser√£o armazenados arquivos de compila√ß√£o
BUILD_DIR := build
# Nome da pasta em que ser√£o armazenadas as caixas de mensagens de cada usu√°rio.
STORAGE_DIR := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))users
#+end_src

Agora, vamos definir um alvo para limpar os arquivos de compila√ß√£o do projeto, caso necess√°rio:

#+begin_src makefile
clean:
	@echo "üßπ Cleaning ..."
	@rm -rf $(BUILD_DIR)
#+end_src

E o nosso primeiro alvo para a compila√ß√£o de um dos arquivos de c√≥digo em objeto:

#+begin_src makefile
$(BUILD_DIR)/$(SRC_DIR)/core/mailbox.o: $(SRC_DIR)/core/mailbox.cpp
	@echo "üèõÔ∏è Building $(SRC_DIR)/core/mailbox.cpp ..."
	@mkdir -p $(BUILD_DIR)/$(SRC_DIR)/core/
	@$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" \
		-c $(SRC_DIR)/core/mailbox.cpp \
		-o $(BUILD_DIR)/$(SRC_DIR)/core/mailbox.o
#+end_src

Este alvo j√° √© funcional, podemo execut√°-lo com o comando ~make build/src/core/mailbox.o~. Mas, ainda podemos melhor√°-lo bastante.

Note que o nome do alvo √© exatamente o nome do caminho para o arquivo objeto. Isto n√£o √© coincid√™ncia! Podemos acessar o nome do alvo dentro da lista de comandos utilizando uma vari√°vel especial ~$@~:

#+begin_src makefile
$(BUILD_DIR)/$(SRC_DIR)/core/mailbox.o: $(SRC_DIR)/core/mailbox.cpp
	@echo "üèõÔ∏è Building $(SRC_DIR)/core/mailbox.cpp ..."
	@mkdir -p $(dir $@)
	@$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" \
		-c $(SRC_DIR)/core/mailbox.cpp \
		-o $@
#+end_src

De maneira similar, podemos nos referir a *primeira* depend√™ncia do alvo atrav√©s da vari√°vel ~$<~:


#+begin_src makefile
$(BUILD_DIR)/$(SRC_DIR)/core/mailbox.o: $(SRC_DIR)/core/mailbox.cpp
	@echo "üèõÔ∏è Building $(SRC_DIR)/core/mailbox.cpp ..."
	@mkdir -p $(dir $@)
	@$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" -c $< -o $@
#+end_src

Bem melhor! Temos o nosso primeiro alvo de compila√ß√£o!

Mas, e para compilarmos os arquivos restantes? Ser√° que precisamos de um alvo para cada arquivo? N√£o!

#+begin_src makefile
$(BUILD_DIR)/$(SRC_DIR)/%.o: $(SRC_DIR)/%.cpp
	@echo "üèõÔ∏è Building $< ..."
	@mkdir -p $(dir $@)
	@$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" -c $< -o $@
#+end_src

O padr√£o =%.cpp= ir√° casar com =core/mailapp.cpp=, =core/mailbox.cpp=, e tamb√©m com =storage/yaml.cpp=. Agora, conseguimos compilar cada um dos tr√™s arquivos separadamente.

Mas, n√£o queremos compilar separadamente... queremos compilar a biblioteca inteira com um √∫nico comando! Neste caso em espec√≠fico, o resultado da compila√ß√£o n√£o ser√° um execut√°vel, mas sim um arquivo ".so" (shared object, uma biblioteca).

Vamos criar um alvo para gerar este arquivo, mas antes precisamos coletar todos os arquivos objetos que ser√£o utilizados:

#+begin_src makefile
SRC_FILES := $(wildcard $(SRC_DIR)/*/*.cpp)
OBJ_SRC_FILES := $(SRC_FILES:.cpp=.o)
#+end_src

Agora, podemos criar um alvo para gerar o arquivo da biblioteca (este arquivo sempre come√ßa com o prefixo =lib=):

#+begin_src makefile
$(BUILD_DIR)/libmail.so: $(addprefix $(BUILD_DIR)/,$(OBJ_SRC_FILES))
	@echo "üîß Preparing library ..."
	@mkdir -p $(BUILD_DIR)
	@$(CXX) -shared $^ -o $(BUILD_DIR)/libmail.so
#+end_src

Por fim, vamos criar um alvo =build=, que depende do arquivo =libmail.so=:

#+begin_src makefile
build: $(BUILD_DIR)/libmail.so
#+end_src

Assim, para compilar o projeto basta utilizar o comando =make build=. A ferramenta =make= ainda possui um alvo padr√£o, caso nenhum seja informado: o primeiro alvo no arquivo. Ou seja, assumindo que o alvo =build= √© o primeiro que aparece no =Makefile=, basta rodar o comando =make=.

Se executarmos o comando =make build= novamente, veremos que nada ser√° realizado, pois j√° est√° tudo atualizado. E, caso fa√ßamos alguma altera√ß√£o em algum arquivo, apenas este arquivo ser√° recompilado.

No entando, na configura√ß√£o atual do nosso =Makefile= apenas altera√ß√µes nos arquivos =.cpp= s√£o levadas em considera√ß√£o. Gostar√≠amos, tamb√©m, que altera√ß√µes nos arquivos =.hpp= fossem consideradas (por exemplo, se alterarmos um par√¢metro de alguma fun√ß√£o).

Precisar√≠amos incluir os arquivos de cabe√ßalho como depend√™ncias do alvo de compila√ß√£o. Por√©m, cada arquivo =.cpp= depende de cabe√ßalhos espec√≠ficos, e n√£o gostar√≠amos que uma altera√ß√£o em um cabe√ßalho que n√£o √© uma depend√™ncia for√ßasse recompila√ß√µes desnecess√°ria.

Alvos sem nenhum comando podem ser utilizados para adicionar depend√™ncias a um alvo existente. Podemos usar isso para adicionar depend√™ncias espec√≠ficas de cada arquivo. Por exemplo, para o arquivo =src/core/mailbox.cpp=:

#+begin_src makefile
$(BUILD_DIR)/$(SRC_DIR)/core/mailbox.o: include/core/mailapp.hpp include/core/message.hpp
#+end_src

Por√©m, ter que adicionar depend√™ncias manualmente vai contra a ideia de um √∫nico alvo para m√∫ltiplos arquivos...

Felizmente, podemos utilizar o compilador g++ para gerar arquivos de depend√™ncias (como acima), e inclu√≠-los no makefile. Basta adicionar as op√ß√µes =-MMD -MP= ao comando de compila√ß√£o, e incluir os arquivos =.d= gerados no Makefile:

#+begin_src makefile
DEP_FILES := $(SRC_FILES:.cpp=.d)
-include $(addprefix $(BUILD_DIR)/,$(DEP_FILES))

$(BUILD_DIR)/$(SRC_DIR)/%.o: $(SRC_DIR)/%.cpp
	@echo "üèõÔ∏è Building $< ..."
	@mkdir -p $(dir $@)
	@$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" -MMD -MP -c $< -o $@
#+end_src

O arquivo Makefile final, incluindo a parte de testes:

#+html: <details><summary>Makefile (clique aqui)</summary>
#+begin_src makefile
CXX := g++
CXXFLAGS := -std=c++17 -Wall -fPIC

INCLUDE := -I include/
DOCTEST += -I ../ # doctest (n√£o √© o melhor lugar...)

SRC_DIR := src
TEST_DIR := test

BIN_DIR := bin
BUILD_DIR := build

STORAGE_DIR := $(dir $(realpath $(firstword $(MAKEFILE_LIST))))users

define fake_inbox =
- from: "someone0"
  to: "fake-user"
  subject: "subject0"
  content: "received0"
- from: "someone1"
  to: "fake-user"
  subject: "subject1"
  content: "received1"
endef
export fake_inbox

define fake_sent =
- from: "fake-user"
  to: "someone0"
  subject: "subject0"
  content: "sent0"
- from: "fake-user"
  to: "someone1"
  subject: "subject1"
  content: "sent1"
endef
export fake_sent

SRC_FILES := $(wildcard $(SRC_DIR)/*/*.cpp)
TEST_FILES := $(wildcard $(TEST_DIR)/*.cpp $(TEST_DIR)/*/*.cpp)

DEP_FILES := $(SRC_FILES:.cpp=.d)
DEP_FILES += $(TEST_FILES:.cpp=.d)

OBJ_SRC_FILES := $(SRC_FILES:.cpp=.o)
OBJ_TEST_FILES := $(OBJ_SRC_FILES)
OBJ_TEST_FILES += $(TEST_FILES:.cpp=.o)

-include $(addprefix $(BUILD_DIR)/,$(DEP_FILES))

build: $(BUILD_DIR)/libmail.so

$(BUILD_DIR)/libmail.so: $(addprefix $(BUILD_DIR)/,$(OBJ_SRC_FILES))
	@echo "üîß Preparing library ..."
	@mkdir -p $(BUILD_DIR)
	@$(CXX) -shared $^ -o $(BUILD_DIR)/libmail.so

test: $(BIN_DIR)/test
	@$(BIN_DIR)/test

$(BIN_DIR)/test: $(addprefix $(BUILD_DIR)/,$(OBJ_TEST_FILES))
	@echo "üîß Preparing test suite ..."
	@mkdir -p $(BIN_DIR)
	@$(CXX) $(CXXFLAGS) $^ -o $@

$(BUILD_DIR)/$(SRC_DIR)/%.o: $(SRC_DIR)/%.cpp
	@echo "üèõÔ∏è Building $< ..."
	@mkdir -p $(dir $@)
	@$(CXX) $(CXXFLAGS) $(INCLUDE) -D STORAGE_DIR=\"$(STORAGE_DIR)\" -MMD -MP -c $< -o $@

$(BUILD_DIR)/$(TEST_DIR)/%.o: $(TEST_DIR)/%.cpp
	@echo "üèõÔ∏è Building $< ..."
	@mkdir -p $(dir $@)
	@mkdir -p $(STORAGE_DIR)/fake-load
	@echo "$$fake_inbox" > $(STORAGE_DIR)/fake-load/inbox.yaml
	@echo "$$fake_sent" > $(STORAGE_DIR)/fake-load/sent.yaml
	@$(CXX) $(CXXFLAGS) $(INCLUDE) $(DOCTEST) -D STORAGE_DIR=\"$(STORAGE_DIR)\" -MMD -MP -c $< -o $@

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf $(BUILD_DIR) $(BIN_DIR)
#+end_src
#+html: </details>
