                 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                  NOTAS DE AULA - 12 INTRODUÃ‡ÃƒO A POO

                           Luigi D. C. Soares
                 â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


Paradigmas de ProgramaÃ§Ã£o
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  O que sÃ£o paradigmas de programaÃ§Ã£o?
  â€¢ Modelos de computaÃ§Ã£o
  â€¢ Estilos de descriÃ§Ã£o de soluÃ§Ãµes de problemas

  Os paradigmas sÃ£o diversos. A seguir estÃ£o os principais:

  â”Œâ”€â”€â”€â”€
  â”‚      Imperativo                              Declarativo
  â”‚        /    \                                  /     \
  â”‚       /      \                                /       \
  â”‚ Procedural  Orientado a Objetos          Funcional   LÃ³gico
  â””â”€â”€â”€â”€

  Exemplificando:
  â€¢ Imperativo: descreve computaÃ§Ã£o como aÃ§Ãµes que alteram o estado
    â€¢ Orientado a Objetos:
      â€¢ Dados e procedimentos encapsulados em objetos
      â€¢ Diversos objetos
      â€¢ InteraÃ§Ã£o/comunicaÃ§Ã£o entre objetos, por meio de mensagens
  â€¢ Funcional:
    â€¢ FunÃ§Ãµes puras
    â€¢ Dados imutÃ¡veis
    â€¢ ComposiÃ§Ã£o de funÃ§Ãµes
    â€¢ entrada â€“> funÃ§Ã£o 1 â€“> funÃ§Ã£o 2 â€“> â€¦ â€“> funÃ§Ã£o n â€“> resultado

  Dizer que uma linguagem Ã© orientada a objetos, ou funcional, ou que
  segue algum paradigma quer dizer que esta linguagem possui
  funcionalidades/ferramentas que facilitam a construÃ§Ã£o de soluÃ§Ãµes
  seguindos tais paradigmas.

  â€¢ Java Ã© 100% orientado a objetos (OO)
  â€¢ C segue o paradigma procedural
  â€¢ Haskell Ã© uma linguagem puramente funcional, tudo Ã© imutÃ¡vel,
    funÃ§Ãµes sÃ£o sempre puras, nÃ£o possui loops
  â€¢ Algumas linguages sÃ£o "multi-paradigmas":
    â€¢ C++: te permite a escrita de programas no paradigma OO e no
      paradigma procedural
    â€¢ Scala: OO mas te permite escrever cÃ³digo em um estilo funcional
      (atÃ© certo nÃ­vel)
    â€¢ Python: OO, procedural, e um pouco de funcional
    â€¢ Racket: te encoraja a escrever no estilo funcional, mas tambÃ©m te
      permite usar OO

  Apenas por curiosidade:

  â€¢ Fibonacci em Haskell

  â”Œâ”€â”€â”€â”€
  â”‚ fib :: Int -> Int
  â”‚ fib 0 = 0
  â”‚ fib 1 = 1
  â”‚ fib n = fib (n-1) + fib (n-2)
  â””â”€â”€â”€â”€

  â€¢ E um exemplo de encadeamento de funÃ§Ãµes em Elixir (note que funÃ§Ãµes
    sÃ£o passadas para funÃ§Ãµes)

  â”Œâ”€â”€â”€â”€
  â”‚ numbers =
  â”‚   1..100
  â”‚   |> Stream.map(fn x -> x * 2 end)
  â”‚   |> Stream.filter(fn x -> rem(x, 2) == 0 end)
  â”‚   |> Stream.take_every(3)
  â”‚   |> Enum.to_list()
  â””â”€â”€â”€â”€


ProgramaÃ§Ã£o Procedural
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  Vamos implementar uma caixa de emails de forma procedural. Primeiro,
  comeÃ§amos com a estrutura das mensagens:

  `include/core/message.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ #include <string>
  â”‚ 
  â”‚ namespace mail_lib::core {
  â”‚ struct Message {
  â”‚   std::string from;
  â”‚   std::string to;
  â”‚   std::string subject;
  â”‚   std::string content;
  â”‚ };
  â”‚ }
  â””â”€â”€â”€â”€

  Agora, vamos declarar a estrutura da mailbox e as operaÃ§Ãµes
  relacionadas:

  `include/core/mailbox.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ #include "message.hpp"
  â”‚ 
  â”‚ #include <string>
  â”‚ #include <vector>
  â”‚ 
  â”‚ namespace mail_lib::core {
  â”‚ struct Mailbox {
  â”‚   std::string name;
  â”‚   std::vector<Message> msgs;
  â”‚ };
  â”‚ 
  â”‚ namespace mailbox {
  â”‚ /// @brief Inicializa a caixa com um determinado nome e mensagens iniciais
  â”‚ ///
  â”‚ /// @param name Nome da caixa de mensagens (e.g., inbox)
  â”‚ /// @param msgs Mensagens iniciais (a **Ãºtima** Ã© a mais recente)
  â”‚ Mailbox init(std::string name, std::vector<Message> const &msgs);
  â”‚ 
  â”‚ /// @brief Adiciona uma mensagem ao final da lista
  â”‚ /// @param mbox Mailbox a ser modificada
  â”‚ /// @param msg Mensagem a ser adicionada
  â”‚ /// @return A prÃ³pria caixa de mensagens, para chamadas consecutivas
  â”‚ Mailbox &add(Mailbox &mbox, Message msg);
  â”‚ }
  â”‚ }
  â””â”€â”€â”€â”€

  Agora, vamos criar alguns testes para a mailbox:

  `test/core/mailbox.cpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #include "doctest.hpp"
  â”‚ #include "core/message.hpp"
  â”‚ #include "core/mailbox.hpp"
  â”‚ 
  â”‚ #include <vector>
  â”‚ 
  â”‚ using mail_lib::core::Mailbox;
  â”‚ using mail_lib::core::Message;
  â”‚ 
  â”‚ namespace mailbox = mail_lib::core::mailbox;
  â”‚ 
  â”‚ void check_msg(Message a, Message b) {
  â”‚   CHECK_EQ(a.from, b.from);
  â”‚   CHECK_EQ(a.to, b.to);
  â”‚   CHECK_EQ(a.content, b.content);
  â”‚ }
  â”‚ 
  â”‚ TEST_CASE("Adicionando mensagens Ã  caixa de entrada vazia") {
  â”‚   Mailbox mbox = mailbox::init("inbox", {});
  â”‚ 
  â”‚   Message msg0 = { "from0", "to0", "content0" };
  â”‚   Message msg1 = { "from1", "to1", "content1" };
  â”‚ 
  â”‚   mailbox::add(mailbox::add(mbox, msg0), msg1);
  â”‚   std::vector<Message> msgs = mbox.msgs;
  â”‚ 
  â”‚   CHECK_EQ(msgs.size(), 2);
  â”‚   check_msg(msg0, msgs[0]);
  â”‚   check_msg(msg1, msgs[1]);
  â”‚ }
  â”‚ 
  â”‚ TEST_CASE("Adicionando mensagens Ã  caixa jÃ¡ preenchida") {
  â”‚   std::vector<Message> old_msgs = {{ "from0", "to0", "content0" }};
  â”‚   Mailbox mbox = mailbox::init("inbox", old_msgs);
  â”‚ 
  â”‚   mailbox::add(mbox, { "from1", "to1", "content1" });
  â”‚   std::vector<Message> msgs = mbox.msgs;
  â”‚ 
  â”‚   CHECK_EQ(msgs.size(), 2);
  â”‚   check_msg(old_msgs[0], msgs[0]);
  â”‚   check_msg({ "from1", "to1", "content1" } , msgs[1]);
  â”‚ }
  â””â”€â”€â”€â”€

  `test/driver.cpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
  â”‚ #include <doctest.hpp>
  â””â”€â”€â”€â”€

  E, por fim, implementar as funÃ§Ãµes relacionadas a mailbox:

  `src/core/mailbox.cpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #include "core/mailbox.hpp"
  â”‚ #include "core/message.hpp"
  â”‚ 
  â”‚ #include <vector>
  â”‚ #include <iostream>
  â”‚ 
  â”‚ namespace mail_lib::core::mailbox {
  â”‚ Mailbox init(std::string name, std::vector<Message> const &msgs) {
  â”‚   return { name, msgs };
  â”‚ }
  â”‚ 
  â”‚ Mailbox &add(Mailbox &mbox, Message msg) {
  â”‚   mbox.msgs.push_back(msg);
  â”‚   return mbox;
  â”‚ }
  â”‚ }
  â””â”€â”€â”€â”€

  E agora, vamos compilar e executar os testes:

  `Makefile'

  â”Œâ”€â”€â”€â”€
  â”‚ CXX := g++
  â”‚ CXXFLAGS := -std=c++17 -Wall -fPIC
  â”‚ 
  â”‚ INCLUDE := -I include/
  â”‚ DOCTEST += -I ../../ # doctest, relativo a pasta 11_poo-intro/procedural
  â”‚ 
  â”‚ SRC_DIR := src
  â”‚ TEST_DIR := test
  â”‚ BUILD_DIR := build
  â”‚ BIN_DIR := bin
  â”‚ 
  â”‚ SRC_FILES := $(wildcard $(SRC_DIR)/*/*.cpp)
  â”‚ TEST_FILES := $(wildcard $(TEST_DIR)/*.cpp $(TEST_DIR)/*/*.cpp)
  â”‚ 
  â”‚ DEP_FILES := $(SRC_FILES:.cpp=.d)
  â”‚ DEP_FILES += $(TEST_FILES:.cpp=.d)
  â”‚ 
  â”‚ OBJ_SRC_FILES := $(SRC_FILES:.cpp=.o)
  â”‚ OBJ_TEST_FILES := $(OBJ_SRC_FILES)
  â”‚ OBJ_TEST_FILES += $(TEST_FILES:.cpp=.o)
  â”‚ 
  â”‚ -include $(addprefix $(BUILD_DIR)/,$(DEP_FILES))
  â”‚ 
  â”‚ test: $(BIN_DIR)/test
  â”‚         @$(BIN_DIR)/test
  â”‚ 
  â”‚ $(BIN_DIR)/test: $(addprefix $(BUILD_DIR)/,$(OBJ_TEST_FILES))
  â”‚         @echo "ğŸ”§ Preparing test suite ..."
  â”‚         @mkdir -p $(BIN_DIR)
  â”‚         @$(CXX) $(CXXFLAGS) $^ -o $@
  â”‚ 
  â”‚ $(BUILD_DIR)/$(SRC_DIR)/%.o: $(SRC_DIR)/%.cpp
  â”‚         @echo "ğŸ›ï¸ Building $< ..."
  â”‚         @mkdir -p $(dir $@)
  â”‚         @$(CXX) $(CXXFLAGS) $(INCLUDE) -MMD -MP -c $< -o $@
  â”‚ 
  â”‚ $(BUILD_DIR)/$(TEST_DIR)/%.o: $(TEST_DIR)/%.cpp
  â”‚         @echo "ğŸ›ï¸ Building $< ..."
  â”‚         @mkdir -p $(dir $@)
  â”‚         @$(CXX) $(CXXFLAGS) $(INCLUDE) $(DOCTEST) -MMD -MP -c $< -o $@
  â”‚ 
  â”‚ clean:
  â”‚         @echo "ğŸ§¹ Cleaning ..."
  â”‚         @rm -rf $(BUILD_DIR) $(BIN_DIR)
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ cd procedural/
  â”‚ make clean
  â”‚ make test
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ ğŸ§¹ Cleaning ...
  â”‚ ğŸ›ï¸ Building src/core/mailbox.cpp ...
  â”‚ ğŸ›ï¸ Building test/driver.cpp ...
  â”‚ ğŸ›ï¸ Building test/core/mailbox.cpp ...
  â”‚ ğŸ”§ Preparing test suite ...
  â”‚ [doctest] doctest version is "2.4.11"
  â”‚ [doctest] run with "--help" for options
  â”‚ ===============================================================================
  â”‚ [doctest] test cases:  2 |  2 passed | 0 failed | 0 skipped
  â”‚ [doctest] assertions: 14 | 14 passed | 0 failed |
  â”‚ [doctest] Status: SUCCESS!
  â””â”€â”€â”€â”€


ProgramaÃ§Ã£o Orientada a Objetos (POO)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  Classe:
  â€¢ Conceito, ideia, abstraÃ§Ã£o
  â€¢ Descreve propriedades em comum
  â€¢ Agrupa atributos e operaÃ§Ãµes em uma mesma entidade
  â€¢ Exemplo: Carro

  Objeto:
  â€¢ Ã‰ uma *instÃ¢ncia* de uma classe, existe em tempo de execuÃ§Ã£o
  â€¢ Possui um estado
  â€¢ Exemplo: Uno (de firma, com escada), Ferrari

  Voltando ao exemplo da caixa de emails, vamos reescrevÃª-lo utilizando
  orientaÃ§Ã£o a objetos (basicamente o que a gente jÃ¡ vem fazendo hÃ¡
  algum tempo).

  A estrutura das mensagens segue da mesma forma:

  `include/core/message.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ #include <string>
  â”‚ 
  â”‚ namespace mail_lib::core {
  â”‚ struct Message {
  â”‚   std::string from;
  â”‚   std::string to;
  â”‚   std::string subject;
  â”‚   std::string content;
  â”‚ };
  â”‚ }
  â””â”€â”€â”€â”€

  Por outro lado, a definiÃ§Ã£o da Mailbox serÃ¡ um pouco diferente:
  â€¢ Vamos grupar as operaÃ§Ãµes junto dos atributos
  â€¢ Vamos tornar os atributos privados
  â€¢ Vamos definir formas de acesso a estes atributos (apenas leitura)

  `include/core/mailbox.hpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #pragma once
  â”‚ 
  â”‚ #include "message.hpp"
  â”‚ 
  â”‚ #include <string>
  â”‚ #include <vector>
  â”‚ 
  â”‚ namespace mail_lib::core {
  â”‚ class Mailbox {
  â”‚ public:
  â”‚   /// @brief Inicializa a caixa com um determinado nome e mensagens iniciais
  â”‚   ///
  â”‚   /// @param name Nome da caixa de mensagens (e.g., inbox)
  â”‚   /// @param msgs Mensagens iniciais (a **Ãºtima** Ã© a mais recente)
  â”‚   Mailbox(std::string name, std::vector<Message> const &msgs);
  â”‚ 
  â”‚   /// @brief Adiciona uma mensagem ao final da lista
  â”‚   /// @param msg Mensagem a ser adicionada
  â”‚   /// @return A prÃ³pria caixa de mensagens, para chamadas consecutivas
  â”‚   Mailbox &add(Message msg);
  â”‚ 
  â”‚   /// @return A lista de mensagens, em que o Ãºltimo elemento Ã©
  â”‚   ///         a mensagem adicionada mais recentemente
  â”‚   std::vector<Message> read_all() const;
  â”‚ 
  â”‚   /// @return Nome da caixa de entrada
  â”‚   std::string name() const;
  â”‚ 
  â”‚ private:
  â”‚   std::string _name;
  â”‚   std::vector<Message> _msgs;
  â”‚ };
  â”‚ }
  â””â”€â”€â”€â”€

  Os testes e a implementaÃ§Ã£o:

  Agora, vamos criar alguns testes para a mailbox:

  `test/core/mailbox.cpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #include "doctest.hpp"
  â”‚ #include "core/message.hpp"
  â”‚ #include "core/mailbox.hpp"
  â”‚ 
  â”‚ #include <vector>
  â”‚ 
  â”‚ using mail_lib::core::Mailbox;
  â”‚ using mail_lib::core::Message;
  â”‚ 
  â”‚ void check_msg(Message a, Message b) {
  â”‚   CHECK_EQ(a.from, b.from);
  â”‚   CHECK_EQ(a.to, b.to);
  â”‚   CHECK_EQ(a.content, b.content);
  â”‚ }
  â”‚ 
  â”‚ TEST_CASE("Adicionando mensagens Ã  caixa de entrada vazia") {
  â”‚   Mailbox mbox("inbox", {});
  â”‚ 
  â”‚   Message msg0 = { "from0", "to0", "content0" };
  â”‚   Message msg1 = { "from1", "to1", "content1" };
  â”‚ 
  â”‚   mbox.add(msg0).add(msg1);
  â”‚   std::vector<Message> msgs = mbox.read_all();
  â”‚ 
  â”‚   CHECK_EQ(msgs.size(), 2);
  â”‚   check_msg(msg0, msgs[0]);
  â”‚   check_msg(msg1, msgs[1]);
  â”‚ }
  â”‚ 
  â”‚ TEST_CASE("Adicionando mensagens Ã  caixa jÃ¡ preenchida") {
  â”‚   std::vector<Message> old_msgs = {{ "from0", "to0", "content0" }};
  â”‚   Mailbox mbox("inbox", old_msgs);
  â”‚ 
  â”‚   mbox.add({ "from1", "to1", "content1" });
  â”‚   std::vector<Message> msgs = mbox.read_all();
  â”‚ 
  â”‚   CHECK_EQ(msgs.size(), 2);
  â”‚   check_msg(old_msgs[0], msgs[0]);
  â”‚   check_msg({ "from1", "to1", "content1" } , msgs[1]);
  â”‚ }
  â””â”€â”€â”€â”€

  `test/driver.cpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
  â”‚ #include <doctest.hpp>
  â””â”€â”€â”€â”€

  E, por fim, implementar as funÃ§Ãµes relacionadas a mailbox:

  `src/core/mailbox.cpp'

  â”Œâ”€â”€â”€â”€
  â”‚ #include "core/mailbox.hpp"
  â”‚ #include "core/message.hpp"
  â”‚ 
  â”‚ #include <vector>
  â”‚ #include <iostream>
  â”‚ 
  â”‚ namespace mail_lib::core {
  â”‚ Mailbox::Mailbox(std::string name, std::vector<Message> const &msgs) {
  â”‚   _name = name;
  â”‚   _msgs = msgs;
  â”‚ }
  â”‚ 
  â”‚ Mailbox &Mailbox::add(Message msg) {
  â”‚   _msgs.push_back(msg);
  â”‚   return *this;
  â”‚ }
  â”‚ 
  â”‚ std::vector<Message> Mailbox::read_all() const {
  â”‚   return _msgs;
  â”‚ }
  â”‚ 
  â”‚ std::string Mailbox::name() const {
  â”‚   return _name;
  â”‚ }
  â”‚ }
  â””â”€â”€â”€â”€

  Compilando e executando os testes:

  â”Œâ”€â”€â”€â”€
  â”‚ cd poo/
  â”‚ make clean
  â”‚ make test
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ ğŸ§¹ Cleaning ...
  â”‚ ğŸ›ï¸ Building src/core/mailbox.cpp ...
  â”‚ ğŸ›ï¸ Building test/driver.cpp ...
  â”‚ ğŸ›ï¸ Building test/core/mailbox.cpp ...
  â”‚ ğŸ”§ Preparing test suite ...
  â”‚ [doctest] doctest version is "2.4.11"
  â”‚ [doctest] run with "--help" for options
  â”‚ ===============================================================================
  â”‚ [doctest] test cases:  2 |  2 passed | 0 failed | 0 skipped
  â”‚ [doctest] assertions: 14 | 14 passed | 0 failed |
  â”‚ [doctest] Status: SUCCESS!
  â””â”€â”€â”€â”€


PrincÃ­pios fundamentais de POO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  â€¢ AbstraÃ§Ã£o:
    â€¢ Elimine o irrelevante, enfatize o essencial
    â€¢ Classes sÃ£o abstraÃ§Ãµes de conceitos
    â€¢ Podemos ter classes abstratas (i.e. que sequer especificam a
      implementaÃ§Ã£o)
      â€¢ NÃ£o podem ser instanciadas
      â€¢ Em C++, implementado com funÃ§Ãµes virtuais
      â€¢ AbstractSet contÃ©m apenas o contrato, as operaÃ§Ãµes
      â€¢ OrderedSet implementa com ordem garantida (Ã¡rvore)
      â€¢ UnorderedSet implementa sem garantia de ordem (hash)

  â€¢ Encapsulamento:
    â€¢ Ocultar informaÃ§Ã£o
    â€¢ Esconda o desnecessÃ¡rio

  â€¢ HeranÃ§a:
    â€¢ Modele a semelhanÃ§a, mas permita a diferenÃ§a
    â€¢ Pessoa: tem nome, cpf
    â€¢ Pessoa â€“> Estudante (especÃ­fico: matrÃ­cula)
    â€¢ Pessoa â€“> Professor (especÃ­fico: departamento)

  â€¢ Polimorfismo:
    â€¢ Tratar tipos diferentes de forma homogÃªnea
    â€¢ Mesma contrato, comportamentos diferentes
