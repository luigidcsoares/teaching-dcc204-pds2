#+title: Notas de Aula - 12 Introdu√ß√£o a POO
#+author: Luigi D. C. Soares
#+startup: entitiespretty
#+options: toc:nil  num:nil
* Paradigmas de Programa√ß√£o

O que s√£o paradigmas de programa√ß√£o?
- Modelos de computa√ß√£o
- Estilos de descri√ß√£o de solu√ß√µes de problemas

Os paradigmas s√£o diversos. A seguir est√£o os principais:

#+begin_example
       Imperativo                              Declarativo
         /    \                                  /     \
        /      \                                /       \
  Procedural  Orientado a Objetos          Funcional   L√≥gico
#+end_example

Exemplificando:
- Imperativo: descreve computa√ß√£o como a√ß√µes que alteram o estado
  - Orientado a Objetos:
    - Dados e procedimentos encapsulados em objetos
    - Diversos objetos
    - Intera√ß√£o/comunica√ß√£o entre objetos, por meio de mensagens
- Funcional:
  - Fun√ß√µes puras
  - Dados imut√°veis
  - Composi√ß√£o de fun√ß√µes
  - entrada --> fun√ß√£o 1 --> fun√ß√£o 2 --> ... --> fun√ß√£o n --> resultado

Dizer que uma linguagem √© orientada a objetos, ou funcional, ou que segue algum paradigma quer dizer que esta linguagem possui funcionalidades/ferramentas que facilitam a constru√ß√£o de solu√ß√µes seguindos tais paradigmas.

- Java √© 100% orientado a objetos (OO)
- C segue o paradigma procedural
- Haskell √© uma linguagem puramente funcional, tudo √© imut√°vel, fun√ß√µes s√£o sempre puras, n√£o possui loops
- Algumas linguages s√£o "multi-paradigmas":
  - C++: te permite a escrita de programas no paradigma OO e no paradigma procedural
  - Scala: OO mas te permite escrever c√≥digo em um estilo funcional (at√© certo n√≠vel)
  - Python: OO, procedural, e um pouco de funcional
  - Racket: te encoraja a escrever no estilo funcional, mas tamb√©m te permite usar OO

Apenas por curiosidade:

- Fibonacci em Haskell

#+begin_src haskell
fib :: Int -> Int
fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
#+end_src

- E um exemplo de encadeamento de fun√ß√µes em Elixir (note que fun√ß√µes s√£o passadas para fun√ß√µes)

#+begin_src elixir
numbers =
  1..100
  |> Stream.map(fn x -> x * 2 end)
  |> Stream.filter(fn x -> rem(x, 2) == 0 end)
  |> Stream.take_every(3)
  |> Enum.to_list()
#+end_src

* Programa√ß√£o Procedural

Vamos implementar uma caixa de emails de forma procedural. Primeiro, come√ßamos com a estrutura das mensagens:

=include/core/message.hpp=

#+begin_src C++ :exports code :main no :tangle procedural/include/core/message.hpp
#pragma once

#include <string>

namespace mail_lib::core {
struct Message {
  std::string from;
  std::string to;
  std::string subject;
  std::string content;
};
}
#+end_src

Agora, vamos declarar a estrutura da mailbox e as opera√ß√µes relacionadas:

=include/core/mailbox.hpp=

#+begin_src C++ :exports code :main no :tangle procedural/include/core/mailbox.hpp
#pragma once

#include "message.hpp"

#include <string>
#include <vector>

namespace mail_lib::core {
struct Mailbox {
  std::string name;
  std::vector<Message> msgs;
};

namespace mailbox {
/// @brief Inicializa a caixa com um determinado nome e mensagens iniciais
///
/// @param name Nome da caixa de mensagens (e.g., inbox)
/// @param msgs Mensagens iniciais (a **√∫tima** √© a mais recente)
Mailbox init(std::string name, std::vector<Message> const &msgs);

/// @brief Adiciona uma mensagem ao final da lista
/// @param mbox Mailbox a ser modificada
/// @param msg Mensagem a ser adicionada
/// @return A pr√≥pria caixa de mensagens, para chamadas consecutivas
Mailbox &add(Mailbox &mbox, Message msg);
}
}
#+end_src

Agora, vamos criar alguns testes para a mailbox:

=test/core/mailbox.cpp=

#+begin_src C++ :exports code :main no :tangle procedural/test/core/mailbox.cpp
#include "doctest.hpp"
#include "core/message.hpp"
#include "core/mailbox.hpp"

#include <vector>

using mail_lib::core::Mailbox;
using mail_lib::core::Message;

namespace mailbox = mail_lib::core::mailbox;

void check_msg(Message a, Message b) {
  CHECK_EQ(a.from, b.from);
  CHECK_EQ(a.to, b.to);
  CHECK_EQ(a.subject, b.subject);
  CHECK_EQ(a.content, b.content);
}

TEST_CASE("Adicionando mensagens √† caixa de entrada vazia") {
  Mailbox mbox = mailbox::init("inbox", {});
  
  Message msg0 = { "from0", "to0", "subject0", "content0" };
  Message msg1 = { "from1", "to1", "subject1", "content1" };
  
  mailbox::add(mailbox::add(mbox, msg0), msg1);
  std::vector<Message> msgs = mbox.msgs;
  
  CHECK_EQ(msgs.size(), 2);
  check_msg(msg0, msgs[0]);
  check_msg(msg1, msgs[1]);
}

TEST_CASE("Adicionando mensagens √† caixa j√° preenchida") {
  std::vector<Message> old_msgs = {{ "from0", "to0", "subject0", "content0" }};
  Mailbox mbox = mailbox::init("inbox", old_msgs);
  
  mailbox::add(mbox, { "from1", "to1", "subject1", "content1" });
  std::vector<Message> msgs = mbox.msgs;

  CHECK_EQ(msgs.size(), 2);
  check_msg(old_msgs[0], msgs[0]);
  check_msg({ "from1", "to1", "subject1", "content1" } , msgs[1]);
}
#+end_src

=test/driver.cpp=

#+begin_src C++ :exports code :main no :tangle procedural/test/driver.cpp
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest.hpp>
#+end_src

E, por fim, implementar as fun√ß√µes relacionadas a mailbox:

=src/core/mailbox.cpp=

#+begin_src C++ :exports code :main no :tangle procedural/src/core/mailbox.cpp
#include "core/mailbox.hpp"
#include "core/message.hpp"

#include <vector>
#include <iostream>

namespace mail_lib::core::mailbox {
Mailbox init(std::string name, std::vector<Message> const &msgs) {
  return { name, msgs };
}

Mailbox &add(Mailbox &mbox, Message msg) {
  mbox.msgs.push_back(msg);
  return mbox;
}
}
#+end_src

E agora, vamos compilar e executar os testes:

=Makefile=

#+name: makefile
#+begin_src makefile :tangle procedural/Makefile
CXX := g++
CXXFLAGS := -std=c++17 -Wall -fPIC

INCLUDE := -I include/
DOCTEST += -I ../../ # doctest, relativo a pasta 11_poo-intro/procedural

SRC_DIR := src
TEST_DIR := test
BUILD_DIR := build
BIN_DIR := bin

SRC_FILES := $(wildcard $(SRC_DIR)/*/*.cpp)
TEST_FILES := $(wildcard $(TEST_DIR)/*.cpp $(TEST_DIR)/*/*.cpp)

DEP_FILES := $(SRC_FILES:.cpp=.d)
DEP_FILES += $(TEST_FILES:.cpp=.d)

OBJ_SRC_FILES := $(SRC_FILES:.cpp=.o)
OBJ_TEST_FILES := $(OBJ_SRC_FILES)
OBJ_TEST_FILES += $(TEST_FILES:.cpp=.o)

-include $(addprefix $(BUILD_DIR)/,$(DEP_FILES))

test: $(BIN_DIR)/test
	@$(BIN_DIR)/test

$(BIN_DIR)/test: $(addprefix $(BUILD_DIR)/,$(OBJ_TEST_FILES))
	@echo "üîß Preparing test suite ..."
	@mkdir -p $(BIN_DIR)
	@$(CXX) $(CXXFLAGS) $^ -o $@

$(BUILD_DIR)/$(SRC_DIR)/%.o: $(SRC_DIR)/%.cpp
	@echo "üèõÔ∏è Building $< ..."
	@mkdir -p $(dir $@)
	@$(CXX) $(CXXFLAGS) $(INCLUDE) -MMD -MP -c $< -o $@

$(BUILD_DIR)/$(TEST_DIR)/%.o: $(TEST_DIR)/%.cpp
	@echo "üèõÔ∏è Building $< ..."
	@mkdir -p $(dir $@)
	@$(CXX) $(CXXFLAGS) $(INCLUDE) $(DOCTEST) -MMD -MP -c $< -o $@

clean:
	@echo "üßπ Cleaning ..."
	@rm -rf $(BUILD_DIR) $(BIN_DIR)
#+end_src
        
#+begin_src sh :results scalar :exports both
cd procedural/
make clean
make test
#+end_src

#+RESULTS:
#+begin_example
üßπ Cleaning ...
üèõÔ∏è Building src/core/mailbox.cpp ...
üèõÔ∏è Building test/driver.cpp ...
üèõÔ∏è Building test/core/mailbox.cpp ...
üîß Preparing test suite ...
[doctest] doctest version is "2.4.11"
[doctest] run with "--help" for options
===============================================================================
[doctest] test cases:  2 |  2 passed | 0 failed | 0 skipped
[doctest] assertions: 18 | 18 passed | 0 failed |
[doctest] Status: SUCCESS!
#+end_example

* Programa√ß√£o Orientada a Objetos (POO)

Classe:
  - Conceito, ideia, abstra√ß√£o
  - Descreve propriedades em comum
  - Agrupa atributos e opera√ß√µes em uma mesma entidade
  - Exemplo: Carro
    
Objeto:
  - √â uma *inst√¢ncia* de uma classe, existe em tempo de execu√ß√£o
  - Possui um estado
  - Exemplo: Uno (de firma, com escada), Ferrari

Voltando ao exemplo da caixa de emails, vamos reescrev√™-lo utilizando orienta√ß√£o a objetos (basicamente o que a gente j√° vem fazendo h√° algum tempo).

A estrutura das mensagens segue da mesma forma:

=include/core/message.hpp=

#+begin_src C++ :exports code :main no :tangle poo/include/core/message.hpp
#pragma once

#include <string>

namespace mail_lib::core {
struct Message {
  std::string from;
  std::string to;
  std::string subject;
  std::string content;
};
}
#+end_src

Por outro lado, a defini√ß√£o da Mailbox ser√° um pouco diferente:
- Vamos grupar as opera√ß√µes junto dos atributos
- Vamos tornar os atributos privados
- Vamos definir formas de acesso a estes atributos (apenas leitura)

=include/core/mailbox.hpp=

#+begin_src C++ :exports code :main no :tangle poo/include/core/mailbox.hpp
#pragma once

#include "message.hpp"

#include <string>
#include <vector>

namespace mail_lib::core {
class Mailbox {
public:
  /// @brief Inicializa a caixa com um determinado nome e mensagens iniciais
  ///
  /// @param name Nome da caixa de mensagens (e.g., inbox)
  /// @param msgs Mensagens iniciais (a **√∫tima** √© a mais recente)
  Mailbox(std::string name, std::vector<Message> const &msgs);

  /// @brief Adiciona uma mensagem ao final da lista
  /// @param msg Mensagem a ser adicionada
  /// @return A pr√≥pria caixa de mensagens, para chamadas consecutivas
  Mailbox &add(Message msg);
  
  /// @return A lista de mensagens, em que o √∫ltimo elemento √©
  ///         a mensagem adicionada mais recentemente
  std::vector<Message> read_all() const;

  /// @return Nome da caixa de entrada
  std::string name() const;

private:
  std::string _name;
  std::vector<Message> _msgs;
};
}
#+end_src

O que acabamos de definir √© uma *classe*, o conceito por tr√°s de uma mailbox. A partir desta classe, podemos criar diferentes *inst√¢ncias* (objetos):

#+begin_src C++ :exports code :results none
Mailbox mbox1("inbox", {});
Mailbox mbox2("inbox", { {"from", "to", "subject", "content"} });
Mailbox mbox3("sent", {});
Mailbox mbox4("sent", {});
#+end_src

Quantos objetos diferentes temos acima?

Os testes e a implementa√ß√£o:

=test/core/mailbox.cpp=

#+begin_src C++ :exports code :main no :tangle poo/test/core/mailbox.cpp
#include "doctest.hpp"
#include "core/message.hpp"
#include "core/mailbox.hpp"

#include <vector>

using mail_lib::core::Mailbox;
using mail_lib::core::Message;

void check_msg(Message a, Message b) {
  CHECK_EQ(a.from, b.from);
  CHECK_EQ(a.to, b.to);
  CHECK_EQ(a.subject, b.subject);
  CHECK_EQ(a.content, b.content);
}

TEST_CASE("Adicionando mensagens √† caixa de entrada vazia") {
  Mailbox mbox("inbox", {});
  
  Message msg0 = { "from0", "to0", "subject0", "content0" };
  Message msg1 = { "from1", "to1", "subject1", "content1" };
  
  mbox.add(msg0).add(msg1);
  std::vector<Message> msgs = mbox.read_all();
  
  CHECK_EQ(msgs.size(), 2);
  check_msg(msg0, msgs[0]);
  check_msg(msg1, msgs[1]);
}

TEST_CASE("Adicionando mensagens √† caixa j√° preenchida") {
  std::vector<Message> old_msgs = {{ "from0", "to0", "subject0", "content0" }};
  Mailbox mbox("inbox", old_msgs);
  
  mbox.add({ "from1", "to1", "subject1", "content1" });
  std::vector<Message> msgs = mbox.read_all();

  CHECK_EQ(msgs.size(), 2);
  check_msg(old_msgs[0], msgs[0]);
  check_msg({ "from1", "to1", "subject1", "content1" } , msgs[1]);
}
#+end_src

=test/driver.cpp=

#+begin_src C++ :exports code :main no :tangle poo/test/driver.cpp
#define DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN
#include <doctest.hpp>
#+end_src

E, por fim, implementar as fun√ß√µes relacionadas a mailbox:

=src/core/mailbox.cpp=

#+begin_src C++ :exports code :main no :tangle poo/src/core/mailbox.cpp
#include "core/mailbox.hpp"
#include "core/message.hpp"

#include <vector>
#include <iostream>

namespace mail_lib::core {
Mailbox::Mailbox(std::string name, std::vector<Message> const &msgs) {
  _name = name;
  _msgs = msgs;
}

Mailbox &Mailbox::add(Message msg) {
  _msgs.push_back(msg);
  return *this;
}

std::vector<Message> Mailbox::read_all() const {
  return _msgs;
}

std::string Mailbox::name() const {
  return _name;
}
}
#+end_src

Compilando e executando os testes:

#+begin_src makefile :exports none :noweb yes :tangle poo/Makefile
<<makefile>>
#+end_src

#+begin_src sh :results scalar :exports both
cd poo/
make clean
make test
#+end_src

#+RESULTS:
#+begin_example
üßπ Cleaning ...
üèõÔ∏è Building src/core/mailbox.cpp ...
üèõÔ∏è Building test/driver.cpp ...
üèõÔ∏è Building test/core/mailbox.cpp ...
üîß Preparing test suite ...
[doctest] doctest version is "2.4.11"
[doctest] run with "--help" for options
===============================================================================
[doctest] test cases:  2 |  2 passed | 0 failed | 0 skipped
[doctest] assertions: 18 | 18 passed | 0 failed |
[doctest] Status: SUCCESS!
#+end_example

* Princ√≠pios fundamentais de POO

- Abstra√ß√£o:
  - Elimine o irrelevante, enfatize o essencial
  - Classes s√£o abstra√ß√µes de conceitos
  - Podemos ter classes abstratas (i.e. que sequer especificam a implementa√ß√£o)
    - N√£o podem ser instanciadas
    - Em C++, implementado com fun√ß√µes virtuais
    - AbstractSet cont√©m apenas o contrato, as opera√ß√µes
    - OrderedSet implementa com ordem garantida (√°rvore)
    - UnorderedSet implementa sem garantia de ordem (hash)
    
- Encapsulamento:
  - Ocultar informa√ß√£o
  - Esconda o desnecess√°rio
  
- Heran√ßa:
  - Modele a semelhan√ßa, mas permita a diferen√ßa
  - Pessoa: tem nome, cpf
  - Pessoa --> Estudante (espec√≠fico: matr√≠cula)
  - Pessoa --> Professor (espec√≠fico: departamento)
    
- Polimorfismo:
  - Tratar tipos diferentes de forma homog√™nea
  - Mesma contrato, comportamentos diferentes
